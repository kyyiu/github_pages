"use strict";(self.webpackChunkthree=self.webpackChunkthree||[]).push([[477],{9477:function(t,n,e){e.r(n),e.d(n,{default:function(){return b}});var i=e(2791),o=e(1022),a=e(5171),r=e(5671),c=e(3144),s=e(6145),d=function(){function t(n){(0,r.Z)(this,t),this.game=n,this.scene=n.sence,this.load(),this.tmpPos=new o.Pa4}return(0,c.Z)(t,[{key:"position",get:function(){return void 0!==this.plane&&this.plane.getWorldPosition(this.tmpPos),this.tmpPos}},{key:"visible",set:function(t){this.plane.visible=t}},{key:"load",value:function(){var t=this;(new s.E).load(e(6998),(function(n){t.scene.add(n.scene),t.plane=n.scene,t.propeller=t.plane.getObjectByName("propeller"),t.velocity=new o.Pa4(0,0,.1)}))}},{key:"reset",value:function(){this.plane.position.set(0,0,0),this.plane.visible=!0,this.velocity.set(0,0,.1)}},{key:"update",value:function(t){this.plane&&(void 0!==this.propeller&&this.propeller.rotateZ(1),this.game.active?(this.game.spaceKey?this.velocity.y+=.001:this.velocity.y-=.001,this.velocity.z+=1e-4,this.plane.rotation.set(0,0,.2*Math.sin(3*t),"XYZ"),this.plane.translateZ(this.velocity.z),this.plane.translateY(this.velocity.y)):(this.plane.rotation.set(0,0,.2*Math.sin(3*t),"XYZ"),this.plane.position.y=1.5*Math.cos(t)))}}]),t}(),v={playBtn:"plane_playBtn__DKwIi",instructions:"plane_instructions__qtInT",gameover:"plane_gameover__8m4B0",info:"plane_info__kP8cY",info_img:"plane_info_img__-9coC",life:"plane_life__QLfjJ",score_panel:"plane_score_panel__f4LIv",lives:"plane_lives__r5rN7",score:"plane_score__v9o4l"},l=e(7762),p=e(5331),f=function(){function t(n,i){var a=this;(0,r.Z)(this,t);var c=new o.cJO(20,4);this.obstacles=i,this.uniforms={u_time:{value:0},u_mouse:{value:{x:0,y:0}},u_opacity:{value:.6},u_resolution:{value:{x:0,y:0}},u_tex:{value:(new o.dpR).load(e(8871))}},o.WdD.noise='\n\t//\n\t// Description : Array and textureless GLSL 2D/3D/4D simplex \n\t//               noise functions.\n\t//      Author : Ian McEwan, Ashima Arts.\n\t//  Maintainer : stegu\n\t//     Lastmod : 20110822 (ijm)\n\t//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\t//               Distributed under the MIT License. See LICENSE file.\n\t//               https://github.com/ashima/webgl-noise\n\t//               https://github.com/stegu/webgl-noise\n\t// \n\n\tvec3 mod289(vec3 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 mod289(vec4 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 permute(vec4 x) {\n\t\t return mod289(((x*34.0)+1.0)*x);\n\t}\n\n\t// Permutation polynomial (ring size 289 = 17*17)\n\tvec3 permute(vec3 x) {\n\t  return mod289(((x*34.0)+1.0)*x);\n\t}\n\t\n\tfloat permute(float x){\n\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;;\n\t}\n\n\tvec4 taylorInvSqrt(vec4 r){\n\t  return 1.79284291400159 - 0.85373472095314 * r;\n\t}\n\n\tvec2 fade(vec2 t) {\n\t  return t*t*t*(t*(t*6.0-15.0)+10.0);\n\t}\n\n\tvec3 fade(vec3 t) {\n\t  return t*t*t*(t*(t*6.0-15.0)+10.0);\n\t}\n\t\n\t// Hashed 2-D gradients with an extra rotation.\n\t// (The constant 0.0243902439 is 1/41)\n\tvec2 rgrad2(vec2 p, float rot) {\n\t#if 0\n\t// Map from a line to a diamond such that a shift maps to a rotation.\n\t  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n\t  u = 4.0 * fract(u) - 2.0;\n\t  // (This vector could be normalized, exactly or approximately.)\n\t  return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);\n\t#else\n\t// For more isotropic gradients, sin/cos can be used instead.\n\t  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n\t  u = fract(u) * 6.28318530718; // 2*pi\n\t  return vec2(cos(u), sin(u));\n\t#endif\n\t}\n\n\tfloat snoise(vec3 v){ \n\t  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\t  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\t  vec3 i  = floor(v + dot(v, C.yyy) );\n\t  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\t  vec3 g = step(x0.yzx, x0.xyz);\n\t  vec3 l = 1.0 - g;\n\t  vec3 i1 = min( g.xyz, l.zxy );\n\t  vec3 i2 = max( g.xyz, l.zxy );\n\n\t  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t  //   x1 = x0 - i1  + 1.0 * C.xxx;\n\t  //   x2 = x0 - i2  + 2.0 * C.xxx;\n\t  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t  vec3 x1 = x0 - i1 + C.xxx;\n\t  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\t  i = mod289(i); \n\t  vec4 p = permute( permute( permute( \n\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t  float n_ = 0.142857142857; // 1.0/7.0\n\t  vec3  ns = n_ * D.wyz - D.xzx;\n\n\t  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\t  vec4 x_ = floor(j * ns.z);\n\t  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t  vec4 h = 1.0 - abs(x) - abs(y);\n\n\t  vec4 b0 = vec4( x.xy, y.xy );\n\t  vec4 b1 = vec4( x.zw, y.zw );\n\n\t  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t  vec4 sh = -step(h, vec4(0.0));\n\n\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\t  vec3 p0 = vec3(a0.xy,h.x);\n\t  vec3 p1 = vec3(a0.zw,h.y);\n\t  vec3 p2 = vec3(a1.xy,h.z);\n\t  vec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t  p0 *= norm.x;\n\t  p1 *= norm.y;\n\t  p2 *= norm.z;\n\t  p3 *= norm.w;\n\n\t// Mix final noise value\n\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t  m = m * m;\n\t  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n\t  }\n\n\t// Classic Perlin noise\n\tfloat cnoise(vec2 P){\n\t  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\t  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\t  Pi = mod289(Pi); // To avoid truncation effects in permutation\n\t  vec4 ix = Pi.xzxz;\n\t  vec4 iy = Pi.yyww;\n\t  vec4 fx = Pf.xzxz;\n\t  vec4 fy = Pf.yyww;\n\n\t  vec4 i = permute(permute(ix) + iy);\n\n\t  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n\t  vec4 gy = abs(gx) - 0.5 ;\n\t  vec4 tx = floor(gx + 0.5);\n\t  gx = gx - tx;\n\n\t  vec2 g00 = vec2(gx.x,gy.x);\n\t  vec2 g10 = vec2(gx.y,gy.y);\n\t  vec2 g01 = vec2(gx.z,gy.z);\n\t  vec2 g11 = vec2(gx.w,gy.w);\n\n\t  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\t  g00 *= norm.x;  \n\t  g01 *= norm.y;  \n\t  g10 *= norm.z;  \n\t  g11 *= norm.w;  \n\n\t  float n00 = dot(g00, vec2(fx.x, fy.x));\n\t  float n10 = dot(g10, vec2(fx.y, fy.y));\n\t  float n01 = dot(g01, vec2(fx.z, fy.z));\n\t  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n\t  vec2 fade_xy = fade(Pf.xy);\n\t  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\t  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\t  return 2.3 * n_xy;\n\t}\n\n\t// Classic Perlin noise, periodic variant\n\tfloat pnoise(vec2 P, vec2 rep){\n\t  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\t  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\t  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n\t  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n\t  vec4 ix = Pi.xzxz;\n\t  vec4 iy = Pi.yyww;\n\t  vec4 fx = Pf.xzxz;\n\t  vec4 fy = Pf.yyww;\n\n\t  vec4 i = permute(permute(ix) + iy);\n\n\t  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n\t  vec4 gy = abs(gx) - 0.5 ;\n\t  vec4 tx = floor(gx + 0.5);\n\t  gx = gx - tx;\n\n\t  vec2 g00 = vec2(gx.x,gy.x);\n\t  vec2 g10 = vec2(gx.y,gy.y);\n\t  vec2 g01 = vec2(gx.z,gy.z);\n\t  vec2 g11 = vec2(gx.w,gy.w);\n\n\t  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\t  g00 *= norm.x;  \n\t  g01 *= norm.y;  \n\t  g10 *= norm.z;  \n\t  g11 *= norm.w;  \n\n\t  float n00 = dot(g00, vec2(fx.x, fy.x));\n\t  float n10 = dot(g10, vec2(fx.y, fy.y));\n\t  float n01 = dot(g01, vec2(fx.z, fy.z));\n\t  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n\t  vec2 fade_xy = fade(Pf.xy);\n\t  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\t  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\t  return 2.3 * n_xy;\n\t}\n\t// Classic Perlin noise\n\tfloat cnoise(vec3 P)\n\t{\n\t  vec3 Pi0 = floor(P); // Integer part for indexing\n\t  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n\t  Pi0 = mod289(Pi0);\n\t  Pi1 = mod289(Pi1);\n\t  vec3 Pf0 = fract(P); // Fractional part for interpolation\n\t  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\t  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t  vec4 iz0 = Pi0.zzzz;\n\t  vec4 iz1 = Pi1.zzzz;\n\n\t  vec4 ixy = permute(permute(ix) + iy);\n\t  vec4 ixy0 = permute(ixy + iz0);\n\t  vec4 ixy1 = permute(ixy + iz1);\n\n\t  vec4 gx0 = ixy0 * (1.0 / 7.0);\n\t  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\t  gx0 = fract(gx0);\n\t  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\t  vec4 sz0 = step(gz0, vec4(0.0));\n\t  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\t  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\t  vec4 gx1 = ixy1 * (1.0 / 7.0);\n\t  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\t  gx1 = fract(gx1);\n\t  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\t  vec4 sz1 = step(gz1, vec4(0.0));\n\t  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\t  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n\t  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n\t  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n\t  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n\t  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n\t  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n\t  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n\t  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n\t  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n\t  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\t  g000 *= norm0.x;\n\t  g010 *= norm0.y;\n\t  g100 *= norm0.z;\n\t  g110 *= norm0.w;\n\t  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\t  g001 *= norm1.x;\n\t  g011 *= norm1.y;\n\t  g101 *= norm1.z;\n\t  g111 *= norm1.w;\n\n\t  float n000 = dot(g000, Pf0);\n\t  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\t  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\t  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\t  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\t  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\t  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\t  float n111 = dot(g111, Pf1);\n\n\t  vec3 fade_xyz = fade(Pf0);\n\t  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\t  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\t  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n\t  return 2.2 * n_xyz;\n\t}\n\n\t// Classic Perlin noise, periodic variant\n\tfloat pnoise(vec3 P, vec3 rep)\n\t{\n\t  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n\t  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n\t  Pi0 = mod289(Pi0);\n\t  Pi1 = mod289(Pi1);\n\t  vec3 Pf0 = fract(P); // Fractional part for interpolation\n\t  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\t  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t  vec4 iz0 = Pi0.zzzz;\n\t  vec4 iz1 = Pi1.zzzz;\n\n\t  vec4 ixy = permute(permute(ix) + iy);\n\t  vec4 ixy0 = permute(ixy + iz0);\n\t  vec4 ixy1 = permute(ixy + iz1);\n\n\t  vec4 gx0 = ixy0 * (1.0 / 7.0);\n\t  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\t  gx0 = fract(gx0);\n\t  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\t  vec4 sz0 = step(gz0, vec4(0.0));\n\t  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\t  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\t  vec4 gx1 = ixy1 * (1.0 / 7.0);\n\t  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\t  gx1 = fract(gx1);\n\t  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\t  vec4 sz1 = step(gz1, vec4(0.0));\n\t  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\t  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n\t  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n\t  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n\t  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n\t  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n\t  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n\t  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n\t  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n\t  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n\t  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\t  g000 *= norm0.x;\n\t  g010 *= norm0.y;\n\t  g100 *= norm0.z;\n\t  g110 *= norm0.w;\n\t  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\t  g001 *= norm1.x;\n\t  g011 *= norm1.y;\n\t  g101 *= norm1.z;\n\t  g111 *= norm1.w;\n\n\t  float n000 = dot(g000, Pf0);\n\t  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\t  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\t  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\t  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\t  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\t  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\t  float n111 = dot(g111, Pf1);\n\n\t  vec3 fade_xyz = fade(Pf0);\n\t  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\t  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\t  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n\t  return 2.2 * n_xyz;\n\t}\n\t\n\tfloat turbulence( vec3 p ) {\n\t  float w = 100.0;\n\t  float t = -.5;\n\n\t  for (float f = 1.0 ; f <= 10.0 ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\n\t  }\n\n\t  return t;\n\t}\n\t\n\tfloat turbulence3( vec3 p ) {\n\t  float w = 100.0;\n\t  float t = -.5;\n\n\t  for (float f = 1.0 ; f <= 3.0 ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( pnoise( vec3( power * p ), vec3( 3.0, 3.0, 3.0 ) ) / power );\n\t  }\n\n\t  return t;\n\t}\n\t\n\tfloat turbulence6( vec3 p ) {\n\t  float w = 100.0;\n\t  float t = -.5;\n\n\t  for (float f = 1.0 ; f <= 6.0 ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( pnoise( vec3( power * p ), vec3( 6.0, 6.0, 6.0 ) ) / power );\n\t  }\n\n\t  return t;\n\t}\n\t\n\t//\n\t// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n\t// The first component of the 3-element return vector is the noise value,\n\t// and the second and third components are the x and y partial derivatives.\n\t//\n\tvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n\t  // Hack: offset y slightly to hide some rare artifacts\n\t  pos.y += 0.01;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n\t  // wrap points in (x,y), map to (u,v)\n\t  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n\t  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n\t  vec3 iuw = xw + 0.5 * yw;\n\t  vec3 ivw = yw;\n  \n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Partial derivatives for analytical gradient computation\n\t  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n\t  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  if (t.x < 0.0) {\n\t\tdtdx.x = 0.0;\n\t\tdtdy.x = 0.0;\n\t\tt.x = 0.0;\n\t  }\n\t  if (t.y < 0.0) {\n\t\tdtdx.y = 0.0;\n\t\tdtdy.y = 0.0;\n\t\tt.y = 0.0;\n\t  }\n\t  if (t.z < 0.0) {\n\t\tdtdx.z = 0.0;\n\t\tdtdy.z = 0.0;\n\t\tt.z = 0.0;\n\t  }\n\n\t  // Fourth power of t (and third power for derivative)\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n\t  vec3 t3 = t2 * t;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Final analytical derivative (gradient of a sum of scalar products)\n\t  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n\t  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n\t  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n\t  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n\t  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n\t  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n\t  return 11.0*vec3(n, dn0 + dn1 + dn2);\n\t}\n\n\t//\n\t// 2-D tiling simplex noise with fixed gradients\n\t// and analytical derivative.\n\t// This function is implemented as a wrapper to "psrdnoise",\n\t// at the minimal cost of three extra additions.\n\t//\n\tvec3 psdnoise(vec2 pos, vec2 per) {\n\t  return psrdnoise(pos, per, 0.0);\n\t}\n\n\t//\n\t// 2-D tiling simplex noise with rotating gradients,\n\t// but without the analytical derivative.\n\t//\n\tfloat psrnoise(vec2 pos, vec2 per, float rot) {\n\t  // Offset y slightly to hide some rare artifacts\n\t  pos.y += 0.001;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n\t  // wrap points in (x,y), map to (u,v)\n\t  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n\t  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n\t  vec3 iuw = xw + 0.5 * yw;\n\t  vec3 ivw = yw;\n  \n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  t = max(t, 0.0);\n\n\t  // Fourth power of t\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Rescale to cover the range [-1,1] reasonably well\n\t  return 11.0*n;\n\t}\n\n\t//\n\t// 2-D tiling simplex noise with fixed gradients,\n\t// without the analytical derivative.\n\t// This function is implemented as a wrapper to "psrnoise",\n\t// at the minimal cost of three extra additions.\n\t//\n\tfloat psnoise(vec2 pos, vec2 per) {\n\t  return psrnoise(pos, per, 0.0);\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n\t// The first component of the 3-element return vector is the noise value,\n\t// and the second and third components are the x and y partial derivatives.\n\t//\n\tvec3 srdnoise(vec2 pos, float rot) {\n\t  // Offset y slightly to hide some rare artifacts\n\t  pos.y += 0.001;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  vec3 x = vec3(p0.x, p1.x, p2.x);\n\t  vec3 y = vec3(p0.y, p1.y, p2.y);\n\t  vec3 iuw = x + 0.5 * y;\n\t  vec3 ivw = y;\n  \n\t  // Avoid precision issues in permutation\n\t  iuw = mod289(iuw);\n\t  ivw = mod289(ivw);\n\n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Partial derivatives for analytical gradient computation\n\t  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n\t  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  if (t.x < 0.0) {\n\t\tdtdx.x = 0.0;\n\t\tdtdy.x = 0.0;\n\t\tt.x = 0.0;\n\t  }\n\t  if (t.y < 0.0) {\n\t\tdtdx.y = 0.0;\n\t\tdtdy.y = 0.0;\n\t\tt.y = 0.0;\n\t  }\n\t  if (t.z < 0.0) {\n\t\tdtdx.z = 0.0;\n\t\tdtdy.z = 0.0;\n\t\tt.z = 0.0;\n\t  }\n\n\t  // Fourth power of t (and third power for derivative)\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n\t  vec3 t3 = t2 * t;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Final analytical derivative (gradient of a sum of scalar products)\n\t  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n\t  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n\t  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n\t  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n\t  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n\t  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n\t  return 11.0*vec3(n, dn0 + dn1 + dn2);\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n\t// This function is implemented as a wrapper to "srdnoise",\n\t// at the minimal cost of three extra additions.\n\t//\n\tvec3 sdnoise(vec2 pos) {\n\t  return srdnoise(pos, 0.0);\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with rotating gradients,\n\t// without the analytical derivative.\n\t//\n\tfloat srnoise(vec2 pos, float rot) {\n\t  // Offset y slightly to hide some rare artifacts\n\t  pos.y += 0.001;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n\t  // wrap points in (x,y), map to (u,v)\n\t  vec3 x = vec3(p0.x, p1.x, p2.x);\n\t  vec3 y = vec3(p0.y, p1.y, p2.y);\n\t  vec3 iuw = x + 0.5 * y;\n\t  vec3 ivw = y;\n  \n\t  // Avoid precision issues in permutation\n\t  iuw = mod289(iuw);\n\t  ivw = mod289(ivw);\n\n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  t = max(t, 0.0);\n\n\t  // Fourth power of t\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Rescale to cover the range [-1,1] reasonably well\n\t  return 11.0*n;\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with fixed gradients,\n\t// without the analytical derivative.\n\t// This function is implemented as a wrapper to "srnoise",\n\t// at the minimal cost of three extra additions.\n\t// Note: if this kind of noise is all you want, there are faster\n\t// GLSL implementations of non-tiling simplex noise out there.\n\t// This one is included mainly for completeness and compatibility\n\t// with the other functions in the file.\n\t//\n\tfloat snoise(vec2 pos) {\n\t  return srnoise(pos, 0.0);\n\t}\n\n\tfloat hash(float x, float y) {\n\t\treturn fract(abs(sin(sin(123.321 + x) * (y + 321.123)) * 456.654));\n\t}\n\t\n\tfloat lerp(float a, float b, float t) {\n\t\treturn a * (1.0 - t) + b * t;\n\t}\n\n\tfloat perlin(float x, float y){\n\t\tfloat col = 0.0;\n\t\tfor (int i = 0; i < 8; i++) \n\t\t{\n\t\t\tfloat fx = floor(x);\n\t\t\tfloat fy = floor(y);\n\t\t\tfloat cx = ceil(x);\n\t\t\tfloat cy = ceil(y);\n\t\t\tfloat a = hash(fx, fy);\n\t\t\tfloat b = hash(fx, cy);\n\t\t\tfloat c = hash(cx, fy);\n\t\t\tfloat d = hash(cx, cy);\n\t\t\tcol += lerp(lerp(a, b, fract(y)), lerp(c, d, fract(y)), fract(x));\n\t\t\tcol /= 2.0;\n\t\t\tx /= 2.0;\n\t\t\ty /= 2.0;\n\t\t}\n\t\treturn col;\n\t}\n\t\n\tfloat dperlin(float x, float y){\n\t\tfloat d = perlin(x, y) * 800.0;\n\t\treturn perlin(x + d, y + d);\n\t}\n\t\n\tfloat ddperlin(float x, float y){\n\t\tfloat d = perlin(x, y) * 800.0;\n\t\treturn dperlin(x + d, y + d);\n\t}\n';var s=new o.jyz({uniforms:this.uniforms,vertexShader:t.vshader,fragmentShader:t.fshader,transparent:!0,opacity:.6});this.ball=new o.Kj0(c,s);var d=.05;this.ball.scale.set(d,d,d),n.add(this.ball),this.tweens=[],p.p8.to(this.ball.scale,{x:.2,y:.2,z:.2,duration:1.5,onComplete:function(){a.complete()}}),this.active=!0}return(0,c.Z)(t,[{key:"complete",value:function(){this.ball.parent.remove(this.ball),this.tweens=[],this.active=!1,this.ball.geometry.dispose(),this.ball.material.dispose(),this.obstacles&&this.obstacles.removeExplosion(this)}},{key:"update",value:function(t){this.active&&(this.uniforms.u_time.value+=t,this.uniforms.u_opacity.value=this.ball.material.opacity)}}]),t}();f.vshader="\n#include <noise>\n\nuniform float u_time;\n\nvarying float noise;\n\nvoid main() {\t\n  float time = u_time;\n  float displacement;\n  float b;\n  \n  // add time to the noise parameters so it's animated\n  noise = 10.0 *  -.10 * turbulence( .5 * normal + time );\n  b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );\n  displacement = - 10. * noise + b;\n\n  // move the position along the normal and transform it\n  vec3 newPosition = position + normal * displacement;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\n}\n",f.fshader="\n#define PI 3.141592653589\n#define PI2 6.28318530718\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform float u_time;\nuniform float u_opacity;\nuniform sampler2D u_tex;\n\nvarying float noise;\n\n//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n\n//https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/\n\nfloat random( vec3 scale, float seed ){\n  return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;\n}\n\nvoid main() {\n\n  // get a random offset\n  float r = .01 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\n  // lookup vertically in the texture, using noise and offset\n  // to get the right RGB colour\n  vec2 t_pos = vec2( 0, 1.3 * noise + r );\n  vec4 color = texture2D( u_tex, t_pos );\n\n  gl_FragColor = vec4( color.rgb, u_opacity );\n}\n";var y=function(){function t(n){(0,r.Z)(this,t),this.game=n,this.sence=n.sence,this.loadStart(),this.loadBomb(),this.tmpPos=new o.Pa4,this.explosions=[]}return(0,c.Z)(t,[{key:"loadStart",value:function(){var t=this;(new s.E).load(e(1861),(function(n){t.star=n.scene.children[0],t.star.name="star",void 0!==t.bomb&&t.init()}))}},{key:"loadBomb",value:function(){var t=this;(new s.E).load(e(4780),(function(n){t.bomb=n.scene.children[0],void 0!==t.bomb&&t.init()}))}},{key:"init",value:function(){this.obstacles=[];var t=new o.ZAu;t.add(this.star),this.bomb.rotation.x=.5*-Math.PI,this.bomb.position.y=7.5,t.add(this.bomb);for(var n=!0,e=7.5;e>-8;e-=2.5)if(n=!n,0!==e){var i=this.bomb.clone();i.rotation.x=n?.5*-Math.PI:0,i.position.y=e,t.add(i)}this.obstacles.push(t),this.sence.add(t);for(var a=0;a<3;a++){var r=t.clone();this.sence.add(r),this.obstacles.push(r)}this.reset()}},{key:"reset",value:function(){var t,n=this;for(this.obstacleSpawn={pos:20,offset:5},this.obstacles.forEach((function(t){return n.respawnObstacle(t)}));this.explosions.length>0&&t<100;)this.explosions[0].onComplete(),t++}},{key:"removeExplosion",value:function(t){var n=this.explosions.indexOf(t);-1!=n&&this.explosions.indexOf(n,1)}},{key:"respawnObstacle",value:function(t){this.obstacleSpawn.pos+=30;var n=(2*Math.random()-1)*this.obstacleSpawn.offset;this.obstacleSpawn.offset+=.2,t.position.set(0,n,this.obstacleSpawn.pos),t.children[0].rotation.y=Math.random()*Math.PI*2,t.userData.hit=!1,t.children.forEach((function(t){t.visible=!0}))}},{key:"update",value:function(t){var n,e=this;this.obstacles.forEach((function(i){i.children[0].rotateY(.01);var o=i.position.z-t.z;Math.abs(o)<2&&!i.userData.hit&&(n=i),o<-20&&e.respawnObstacle(i)})),void 0!==n&&n.children.some((function(i){if(i.getWorldPosition(e.tmpPos),e.tmpPos.distanceToSquared(t)<5)return n.userData.hit=!0,e.hit(i),!0}))}},{key:"hit",value:function(t){"star"==t.name?(t.visible=!1,this.game.incScore()):(this.explosions.push(new f(t,this)),this.game.decLives())}},{key:"unMount",value:function(){var t,n=(0,l.Z)(this.obstacles);try{for(n.s();!(t=n.n()).done;){var e=t.value;this.sence.remove(e)}}catch(i){n.e(i)}finally{n.f()}}}]),t}(),g=e(184),x=new o.xsS,u=new o.cPb(70,window.innerWidth/window.innerHeight,.01,100);u.position.set(-4.37,0,-4.75),u.lookAt(0,0,6);var m=new o.Tme;m.add(u);var h=new o.Pa4(0,0,6);x.add(m);var w=new o.vmT(16777215,12303359,1);w.position.set(.5,1,.25),x.add(w);var z=new o.CP7;function b(){var t,n,r=new o.SUY,c={spaceKey:!1,active:!1,sence:x,sounds:{}},s=(0,i.useRef)();function l(){var t=c.sounds;for(var n in t)t[n]&&t[n].isPlaying&&t[n].stop()}function p(t){var n=c.sounds[t];void 0!==n&&(n.isPlaying&&n.stop(),n.play())}function f(){c.score++;var t=document.getElementById("score");c.score%3===0?(c.bonusScore+=3,p("bonus")):p("gliss"),t.innerHTML=c.score+c.bonusScore}function w(){c.lives--,document.getElementById("lives").innerHTML=c.lives,c.lives<=0&&setTimeout(b,1200),p("explosion")}function b(){c.active=!1;var n=document.getElementById("gameover"),e=document.getElementById("playBtn");n.style.display="block",e.style.display="block",t.visible=!1,l(),p("gameover")}function A(){c.spaceKey=!0}function P(){c.spaceKey=!1}function T(t){if(32===t.keyCode)c.spaceKey=!0}function N(t){if(32===t.keyCode)c.spaceKey=!1}function Z(){var t=window.innerWidth,n=window.innerHeight;u.aspect=t/n,u.updateProjectionMatrix(),z.setSize(t,n)}function C(){var e=r.getDelta(),i=r.getElapsedTime();t.update(i),c.active&&n.update(t.position,e),m.position.copy(t.position),m.position.y=0,h.copy(t.position),h.z+=6,u.lookAt(h),z.render(x,u),window.requestAnimationFrame(C)}return(0,i.useEffect)((function(){return window.addEventListener("resize",Z,!1),s.current.appendChild(z.domElement),c.incScore=f,c.decLives=w,function(){var t=new a.x,n=new o.anP(z);n.compileEquirectangularShader(),t.load(e(6623),(function(t){var e=n.fromEquirectangular(t).texture;n.dispose(),x.environment=e}),void 0,(function(t){console.log("EEEE",t)}))}(),x.background=(new o.cBK).load([e(5911),e(8865),e(3342),e(5529),e(7909),e(7558)]),t=new d(c),n=new y(c),document.addEventListener("keydown",T),document.addEventListener("keyup",N),s.current.addEventListener("mousedown",A),s.current.addEventListener("mouseup",P),function(){var t=[{tag:"explosion",path:e(2337)},{tag:"engine",path:e(755),loop:!0},{tag:"gliss",path:e(4023)},{tag:"gameover",path:e(847)},{tag:"bonus",path:e(9555)}],n=new o.SJI;u.add(n),t.forEach((function(t){var e=new o.BbS(n);c.sounds[t.tag]=e,(new o.mTL).load(t.path,(function(n){e.setBuffer(n),e.setLoop(!!t.loop),e.setVolume(.5)}))}))}(),C(),function(){document.removeEventListener("keydown",T),document.removeEventListener("keyup",N),l(),x.remove(t.plane),n.unMount()}}),[]),(0,g.jsxs)("div",{children:[(0,g.jsx)("p",{className:v.instructions,id:"instructions",children:"\u64cd\u4f5c\uff1a\u957f\u6309\u7a7a\u683c\u6216\u8005\u9f20\u6807"}),(0,g.jsxs)("div",{id:"info",className:v.info,children:[(0,g.jsxs)("div",{id:"life",className:v.life,children:[(0,g.jsx)("img",{className:v.info_img,src:e(6948)}),(0,g.jsx)("div",{id:"lives",className:v.lives,children:"3"})]}),(0,g.jsxs)("div",{id:"score_panel",className:v.score_panel,children:[(0,g.jsx)("div",{className:v.score,id:"score",children:"0"}),(0,g.jsx)("img",{className:v.info_img,src:e(8892)})]})]}),(0,g.jsx)("p",{id:"gameover",className:v.gameover,children:"Game Over"}),(0,g.jsx)("button",{className:v.playBtn,id:"playBtn",onClick:function(){var e=document.getElementById("instructions"),i=document.getElementById("playBtn");document.getElementById("gameover").style.display="none",e.style.display="none",i.style.display="none",c.score=0,c.bonusScore=0,c.lives=3,document.getElementById("score").innerHTML=c.score,document.getElementById("lives").innerHTML=c.lives,t.reset(),n.reset(),c.active=!0,p("engine")},children:"\u5f00\u59cb"}),(0,g.jsx)("div",{ref:s})]})}z.setPixelRatio(window.devicePixelRatio),z.outputEncoding=o.knz,z.setSize(window.innerWidth,window.innerHeight)},6623:function(t,n,e){t.exports=e.p+"static/media/venice_sunset_1k.dd2d43c9802c4b7fe36a.hdr"},4780:function(t,n,e){t.exports=e.p+"static/media/bomb.1659929aa01525302fbf.glb"},9555:function(t,n,e){t.exports=e.p+"static/media/bonus.a95d5633d29f0dbd3614.mp3"},755:function(t,n,e){t.exports=e.p+"static/media/engine.dff7caa5ba2d731fbc0a.mp3"},2337:function(t,n,e){t.exports=e.p+"static/media/explosion.0e2aaa9d5a2a40696113.mp3"},847:function(t,n,e){t.exports=e.p+"static/media/gameover.abc9912418c1f01fca9b.mp3"},4023:function(t,n,e){t.exports=e.p+"static/media/gliss.ddb67dda721105a5acd5.mp3"},6998:function(t,n,e){t.exports=e.p+"static/media/microplane.bbfe7b3c9aa4195a5d45.glb"},1861:function(t,n,e){t.exports=e.p+"static/media/star.921c9516da5f9387e520.glb"},8871:function(t){t.exports="data:image/png;base64,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"},8865:function(t,n,e){t.exports=e.p+"static/media/nx.790fabff8728e904e3cb.jpg"},5529:function(t,n,e){t.exports=e.p+"static/media/ny.a73244d8b562b94f7b94.jpg"},7558:function(t,n,e){t.exports=e.p+"static/media/nz.4da26c7864c6e66b8afe.jpg"},5911:function(t,n,e){t.exports=e.p+"static/media/px.ef51c1d8e14e8409d463.jpg"},3342:function(t,n,e){t.exports=e.p+"static/media/py.6ba36a6b71d133757bfc.jpg"},7909:function(t,n,e){t.exports=e.p+"static/media/pz.b45dd69c688ec136d5e8.jpg"},6948:function(t,n,e){t.exports=e.p+"static/media/plane-icon.3c6cf5559b2b02954b6c.png"},8892:function(t){t.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAABECAYAAAAvMQN7AAAACXBIWXMAAAsTAAALEwEAmpwYAAAFBmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDUgNzkuMTY0NTkwLCAyMDIwLzEyLzA5LTExOjU3OjQ0ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjIuMSAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjEtMDMtMDhUMTY6Mzk6MDdaIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMS0wMy0wOFQxNjo0MTozNloiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjEtMDMtMDhUMTY6NDE6MzZaIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjgwNWZlZjM3LWNmYzMtNDA3OC04NGQ0LTc3Zjcz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"},5171:function(t,n,e){e.d(n,{x:function(){return v}});var i=e(5671),o=e(3144),a=e(1752),r=e(1120),c=e(136),s=e(7277),d=e(1022),v=function(t){(0,c.Z)(e,t);var n=(0,s.Z)(e);function e(t){var o;return(0,i.Z)(this,e),(o=n.call(this,t)).type=d.cLu,o}return(0,o.Z)(e,[{key:"parse",value:function(t){var n=function(t,n){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(n||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(n||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(n||""));break;default:console.error("THREE.RGBELoader: Error: "+(n||""))}return-1},e=function(t,n,e){n=n||1024;for(var i=t.pos,o=-1,a=0,r="",c=String.fromCharCode.apply(null,new Uint16Array(t.subarray(i,i+128)));0>(o=c.indexOf("\n"))&&a<n&&i<t.byteLength;)r+=c,a+=c.length,i+=128,c+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(i,i+128)));return-1<o&&(!1!==e&&(t.pos+=a+o+1),r+c.slice(0,o))},i=function(t,n,e,i){var o=t[n+3],a=Math.pow(2,o-128)/255;e[i+0]=t[n+0]*a,e[i+1]=t[n+1]*a,e[i+2]=t[n+2]*a,e[i+3]=1},o=function(t,n,e,i){var o=t[n+3],a=Math.pow(2,o-128)/255;e[i+0]=d.A5E.toHalfFloat(Math.min(t[n+0]*a,65504)),e[i+1]=d.A5E.toHalfFloat(Math.min(t[n+1]*a,65504)),e[i+2]=d.A5E.toHalfFloat(Math.min(t[n+2]*a,65504)),e[i+3]=d.A5E.toHalfFloat(1)},a=new Uint8Array(t);a.pos=0;var r=function(t){var i,o,a=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,c=/^\s*FORMAT=(\S+)\s*$/,s=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,d={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};if(t.pos>=t.byteLength||!(i=e(t)))return n(1,"no header found");if(!(o=i.match(/^#\?(\S+)/)))return n(3,"bad initial token");for(d.valid|=1,d.programtype=o[1],d.string+=i+"\n";!1!==(i=e(t));)if(d.string+=i+"\n","#"!==i.charAt(0)){if((o=i.match(a))&&(d.gamma=parseFloat(o[1])),(o=i.match(r))&&(d.exposure=parseFloat(o[1])),(o=i.match(c))&&(d.valid|=2,d.format=o[1]),(o=i.match(s))&&(d.valid|=4,d.height=parseInt(o[1],10),d.width=parseInt(o[2],10)),2&d.valid&&4&d.valid)break}else d.comments+=i+"\n";return 2&d.valid?4&d.valid?d:n(3,"missing image size specifier"):n(3,"missing format specifier")}(a);if(-1!==r){var c=r.width,s=r.height,v=function(t,e,i){var o=e;if(o<8||o>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(o!==(t[2]<<8|t[3]))return n(3,"wrong scanline width");var a=new Uint8Array(4*e*i);if(!a.length)return n(4,"unable to allocate buffer space");for(var r=0,c=0,s=4*o,d=new Uint8Array(4),v=new Uint8Array(s),l=i;l>0&&c<t.byteLength;){if(c+4>t.byteLength)return n(1);if(d[0]=t[c++],d[1]=t[c++],d[2]=t[c++],d[3]=t[c++],2!=d[0]||2!=d[1]||(d[2]<<8|d[3])!=o)return n(3,"bad rgbe scanline format");for(var p=0,f=void 0;p<s&&c<t.byteLength;){var y=(f=t[c++])>128;if(y&&(f-=128),0===f||p+f>s)return n(3,"bad scanline data");if(y)for(var g=t[c++],x=0;x<f;x++)v[p++]=g;else v.set(t.subarray(c,c+f),p),p+=f,c+=f}for(var u=o,m=0;m<u;m++){var h=0;a[r]=v[m+h],h+=o,a[r+1]=v[m+h],h+=o,a[r+2]=v[m+h],h+=o,a[r+3]=v[m+h],r+=4}l--}return a}(a.subarray(a.pos),c,s);if(-1!==v){var l,p,f;switch(this.type){case d.VzW:f=v.length/4;for(var y=new Float32Array(4*f),g=0;g<f;g++)i(v,4*g,y,4*g);l=y,p=d.VzW;break;case d.cLu:f=v.length/4;for(var x=new Uint16Array(4*f),u=0;u<f;u++)o(v,4*u,x,4*u);l=x,p=d.cLu;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:c,height:s,data:l,header:r.string,gamma:r.gamma,exposure:r.exposure,type:p}}}return null}},{key:"setDataType",value:function(t){return this.type=t,this}},{key:"load",value:function(t,n,i,o){return(0,a.Z)((0,r.Z)(e.prototype),"load",this).call(this,t,(function(t,e){switch(t.type){case d.VzW:case d.cLu:t.encoding=d.rnI,t.minFilter=d.wem,t.magFilter=d.wem,t.generateMipmaps=!1,t.flipY=!0}n&&n(t,e)}),i,o)}}]),e}(d.yxD)}}]);
//# sourceMappingURL=477.985e4974.chunk.js.map