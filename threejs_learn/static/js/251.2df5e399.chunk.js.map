{"version":3,"file":"static/js/251.2df5e399.chunk.js","mappings":"2LAMMA,EAAQ,IAAIC,EAAAA,IACZC,EAAS,IAAID,EAAAA,IACf,GACAE,OAAOC,WAAWD,OAAOE,YACzB,GACA,KAGJH,EAAOI,SAASC,IAAI,EAAE,EAAE,KACxBP,EAAMQ,IAAIN,GAEV,IAAIO,EAAW,IAAIR,EAAAA,IAAqB,EAAG,GAGrCS,EAAW,CACbC,OAAQ,CAAEC,KAAM,IAAKC,MAAO,GAC5BC,UAAW,CACTD,OALS,IAAIZ,EAAAA,KACMc,KAAKC,EAAQ,QAMlCC,aAAc,CAAEL,KAAM,KAAMC,MAAO,IAAIZ,EAAAA,MAGvCiB,EAAW,IAAIjB,EAAAA,IAAsB,CACrCS,SAAUA,EACVS,aC9BJ,yID+BIC,eE/BJ,0+JFkCIC,EAAO,IAAIpB,EAAAA,IAAYQ,EAAUS,GACrClB,EAAMQ,IAAKa,GAEX,IAKIC,EALEC,EAAW,IAAItB,EAAAA,IAMN,aACX,IAAMuB,GAAYC,EAAAA,EAAAA,UAWlB,SAASC,EAAQC,GACVL,IACLZ,EAASC,OAAOE,OAASS,EAAMM,WAC/BL,EAASM,OAAO7B,EAAOE,GACvBC,OAAO2B,sBAAsBJ,GAC/B,CAEA,OAhBAK,EAAAA,EAAAA,YAAU,WAIR,OAHAT,EAAQ,IAAIrB,EAAAA,IACZuB,EAAUQ,QAAQC,YAAYV,EAASW,YACvCR,IACO,WACLJ,EAAQ,IACV,CACF,GAAG,KASIa,EAAAA,EAAAA,KAAA,OAAKC,IAAKZ,GACnB,CAzBe,IAAIa,EAAAA,EAAcnC,EAAQqB,EAASW,YAE3CI,eAAgB,EACzBf,EAASgB,QAAQpC,OAAOC,WAAYD,OAAOE,Y","sources":["practice/shader/fireWork/fireWork.js","practice/shader/fireWork/glsl/vShader.js","practice/shader/fireWork/glsl/fShader.js"],"sourcesContent":["import React, { useEffect, useRef } from \"react\";\r\nimport * as Three from 'three'\r\nimport {OrbitControls} from 'three/examples/jsm/controls/OrbitControls'\r\nimport vertexShader from './glsl/vShader'\r\nimport fragmentShader from './glsl/fShader'\r\n\r\nconst sence = new Three.Scene();\r\nconst camera = new Three.PerspectiveCamera(\r\n    75,\r\n    window.innerWidth/window.innerHeight,\r\n    0.1,\r\n    1000\r\n)\r\n\r\ncamera.position.set(0,0,1.5)\r\nsence.add(camera)\r\n\r\nvar geometry = new Three.PlaneGeometry( 2, 2 );\r\nconst loader = new Three.TextureLoader();\r\nconst texture1  = loader.load(require(\"../../../assets/img/react_logo.png\"));\r\nconst uniforms = {\r\n    u_time: { type: \"f\", value: 1.0 },\r\n    iChannel0: {\r\n      value: texture1\r\n    },\r\n    u_resolution: { type: \"v2\", value: new Three.Vector2() }\r\n};\r\n\r\nvar material = new Three.ShaderMaterial( {\r\n    uniforms: uniforms,\r\n    vertexShader: vertexShader,\r\n    fragmentShader: fragmentShader\r\n} );\r\n\r\nvar mesh = new Three.Mesh( geometry, material );\r\nsence.add( mesh );\r\n\r\nconst renderer = new Three.WebGLRenderer()\r\nconst controls = new OrbitControls(camera, renderer.domElement)\r\n// 设置阻尼，让控制器更真实, 必须在动画循环调用update方法\r\ncontrols.enableDamping = true\r\nrenderer.setSize(window.innerWidth, window.innerHeight)\r\nlet clock;\r\nexport default function() {\r\n    const container = useRef()\r\n  \r\n    useEffect(() => {\r\n      clock = new Three.Clock();\r\n      container.current.appendChild(renderer.domElement)\r\n      refresh()\r\n      return () => {\r\n        clock = null;\r\n      }\r\n    }, [])\r\n\r\n    function refresh(time) {\r\n      if (!clock) return;\r\n      uniforms.u_time.value += clock.getDelta();\r\n      renderer.render(sence, camera)\r\n      window.requestAnimationFrame(refresh)\r\n    }\r\n  \r\n    return <div ref={container}></div>\r\n  }","export default /*glsl*/`  \r\nvarying vec2 vUv;\r\nvoid main() { \r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}`;","export default /* glsl */`\r\nvarying vec2 vUv;\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\nuniform sampler2D iChannel0;\r\n//random value\r\nvec2 N22(vec2 p)\r\n{\r\n  vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\r\n  a += dot(a, a + 34.45);\r\n  return fract(vec2(a.x * a.y, a.y * a.z));\r\n}\r\n\r\nvec3 burst(vec2 st, vec2 pos, float r, vec3 col)\r\n{\r\n    st -= pos;\r\n    r = 0.6 * r * r;\r\n\r\n    /// 发光效果\r\n    return (r / dot(st, st)) * col * 0.6;\r\n}\r\n\r\n/// s = p0 + ut + 0.5at^2\r\n/// 距离加速度公式\r\nvec2 get_pos(vec2 u, vec2 a, vec2 p0, float t, float ang)\r\n{\r\n    /// 根据初始位置、水平和垂直的速度、加速度来更新当前的位置\r\n    vec2 d = p0 + vec2(u.x * cos(ang), u.y * sin(ang)) * t + 0.5 * a * t * t;\r\n    return d;\r\n}\r\n\r\n// t 时刻的粒子速度\r\nvec2 get_velocity(vec2 u, vec2 a, float t, float ang)\r\n{\r\n    /// 根据加速度、当前水平和垂直的速度来更新当前的速度\r\n    return vec2(u.x * cos(ang), u.y * sin(ang)) + a * t;\r\n}\r\n\r\n#define rad(x) radians(x)\r\nfloat np = 100.;\r\nfloat snp = 20.;\r\nfloat R = 0.032;\r\nfloat R_RATIO = 0.04;\r\nfloat ACC_RATIO = 0.03;\r\nfloat ANG = 90.;\r\nvec3 palette(float t) {\r\n  vec3 a = vec3(0.5);\r\n  vec3 b = vec3(0.5);\r\n  vec3 c = vec3(1.0);\r\n  vec3 d = vec3(0.263, 0.416, 0.557);\r\n  return a + b*cos(6.28318*(c*t*d));\r\n}\r\nvoid main()\r\n{\r\n    vec2 uv = vUv.xy ;\r\n    vec3 col = vec3(0.0);\r\n    float t = mod(u_time, 10.);\r\n\r\n    vec2 u = vec2(0.);                ///< 初速度\r\n    const vec2 acc = vec2(0.0, -9.8); ///< 重力加速度 acc\r\n    float ang = rad(ANG);             ///< 上升粒子的发射角度\r\n\r\n    vec3 particles = vec3(0.0); //particle\r\n\r\n   for (float i = 0.; i < np; i++)\r\n   {\r\n      float r = R;\r\n       vec2 rand = N22(vec2(i));\r\n\r\n       /// @note 爆炸前的粒子上升\r\n\r\n      /// 初始位置\r\n       vec2 ip = vec2(sin(30.*rand.x), -1. + r);\r\n\r\n       /// 真正初始化速度\r\n       u = vec2(sin(5.*rand.x), 5. + sin(4.*rand.y));\r\n\r\n       float t_i = t - i / 5.; ///< 时间差异化\r\n        vec2 s = get_pos(u, acc, ip, t_i, ang);\r\n        vec2 v = get_velocity(u, acc, t_i, ang);\r\n\r\n       /// 计算竖直向上的运动时间\r\n        float t_up = u.y * sin(ang) / abs(acc.y);\r\n        /// 根据时间计算出向上运动的最大高度\r\n        vec2 h_max = get_pos(u, acc, ip, t_up, ang);\r\n\r\n        vec3 pcol = palette(u_time);\r\n\r\n\r\n       if (v.y < -0.5) ///< 下落速度超过一定大小则消失\r\n        {\r\n            r = 0.0;    ///< 隐藏\r\n        }\r\n      particles += burst(uv, s, r, pcol); ///< 发射上升的粒子\r\n\r\n\r\n      /// @note 爆炸后的粒子扩散\r\n       /// 当粒子停止上升，且粒子的当前时间已经达到了上升的时间\r\n\r\n        if (v.y > -6.5 && v.y < 0.0 && t_i >= t_up /*&& SPAWN == 1*/)\r\n               {\r\n           /// 把一个圆根据角度分成若干份扇形\r\n           float unit = (360. / snp);\r\n           for (float j = 0.0; j < snp; j++)\r\n          {\r\n               float ang = rad(j * unit);\r\n\r\n                float r = 0.035;             ///< 心形粒子的半径\r\n              r -= (t_i - t_up) * R_RATIO; ///< 根据时间差来改变粒子的大小（变小）\r\n\r\n               /// --------------------------------------------------\r\n               /// @note 根据（单位圆的）角度计算笛卡尔坐标\r\n                float x = cos(ang); //coords of unit circle\r\n                float y = sin(ang);\r\n                /// 心形公式\r\n                y = y + abs(x) * sqrt( (8. - abs(x)) / 50.0 );\r\n              /// 心形速度向量，随着时间而变小\r\n                vec2 heart = vec2(x * x + y * y) * (0.4 / (t_i * sqrt(t_i)));\r\n\r\n                /// 根据心形的当前速度和加速度、初始位置等更新粒子的位置\r\n                vec2 S = get_pos(heart, acc * ACC_RATIO, h_max, t_i - (t_up), ang);\r\n                /// --------------------------------------------------\r\n\r\n                vec3 pcol = palette(u_time);\r\n               particles += burst(uv, S, max(0.0, r), pcol);\r\n           }\r\n        }\r\n\r\n    }\r\n\r\n    col = particles;\r\n    /// vec3 bgImg = texture2D(iChannel0, uv).rgb;\r\n    /// gl_FragColor = vec4(col + bgImg,  1.0);\r\n    gl_FragColor = vec4(col,  1.0);\r\n}`"],"names":["sence","Three","camera","window","innerWidth","innerHeight","position","set","add","geometry","uniforms","u_time","type","value","iChannel0","load","require","u_resolution","material","vertexShader","fragmentShader","mesh","clock","renderer","container","useRef","refresh","time","getDelta","render","requestAnimationFrame","useEffect","current","appendChild","domElement","_jsx","ref","OrbitControls","enableDamping","setSize"],"sourceRoot":""}