{"version":3,"file":"static/js/477.9b8033b1.chunk.js","mappings":"gNAIMA,EAAM,WACV,SAAAA,EAAYC,IAAMC,EAAAA,EAAAA,GAAA,KAAAF,GAChBG,KAAKC,KAAOH,EACZE,KAAKE,MAAQJ,EAAKK,MAClBH,KAAKI,OACLJ,KAAKK,OAAS,IAAIC,EAAAA,GACpB,CAoDC,OApDAC,EAAAA,EAAAA,GAAAV,EAAA,EAAAW,IAAA,WAAAC,IAED,WAIE,YAHmBC,IAAfV,KAAKW,OACPX,KAAKW,MAAMC,iBAAiBZ,KAAKK,QAE5BL,KAAKK,MACd,GAAC,CAAAG,IAAA,UAAAK,IAED,SAAYC,GACVd,KAAKW,MAAMI,QAAUD,CACvB,GAAC,CAAAN,IAAA,OAAAQ,MAED,WAAQ,IAADC,EAAA,MACU,IAAIC,EAAAA,GACZd,KAAKe,EAAQ,OAAoD,SAAAC,GACtEH,EAAKf,MAAMmB,IAAID,EAAKlB,OACpBe,EAAKN,MAAQS,EAAKlB,MAElBe,EAAKK,UAAYL,EAAKN,MAAMY,gBAAgB,aAC5CN,EAAKO,SAAW,IAAIlB,EAAAA,IAAQ,EAAG,EAAI,GAErC,GACF,GAAC,CAAAE,IAAA,QAAAQ,MAED,WACEhB,KAAKW,MAAMc,SAASZ,IAAI,EAAG,EAAG,GAC9Bb,KAAKW,MAAMI,SAAU,EACrBf,KAAKwB,SAASX,IAAI,EAAE,EAAE,GACxB,GAAC,CAAAL,IAAA,SAAAQ,MAED,SAAOU,GACA1B,KAAKW,aAGaD,IAAnBV,KAAKsB,WACPtB,KAAKsB,UAAUK,QAAQ,GAErB3B,KAAKC,KAAK2B,QACP5B,KAAKC,KAAK4B,SAGb7B,KAAKwB,SAASM,GAAK,KAFnB9B,KAAKwB,SAASM,GAAK,KAIrB9B,KAAKwB,SAASO,GAAK,KACnB/B,KAAKW,MAAMqB,SAASnB,IAAI,EAAG,EAAsB,GAAnBoB,KAAKC,IAAW,EAAPR,GAAe,OACtD1B,KAAKW,MAAMwB,WAAWnC,KAAKwB,SAASO,GACpC/B,KAAKW,MAAMyB,WAAWpC,KAAKwB,SAASM,KAEpC9B,KAAKW,MAAMqB,SAASnB,IAAI,EAAG,EAAoB,GAAjBoB,KAAKC,IAAS,EAALR,GAAa,OACpD1B,KAAKW,MAAMc,SAASK,EAAqB,IAAjBG,KAAKI,IAAIX,IAErC,KAAC7B,CAAA,CA1DS,GCHZ,GAAgB,QAAU,uBAAuB,aAAe,4BAA4B,SAAW,wBAAwB,KAAO,oBAAoB,SAAW,wBAAwB,KAAO,oBAAoB,YAAc,2BAA2B,MAAQ,qBAAqB,MAAQ,sB,oBCGhSyC,EAAS,WAwDb,SAAAA,EAAYC,EAAQC,GAAY,IAADvB,EAAA,MAAAlB,EAAAA,EAAAA,GAAA,KAAAuC,GAC7B,IAAMG,EAAW,IAAIC,EAAAA,IAAoB,GAAI,GAC7C1C,KAAKwC,UAAYA,EACjBxC,KAAK2C,SAAW,CACdC,OAAQ,CAAC5B,MAAO,GAChB6B,QAAS,CAAC7B,MAAO,CAAC8B,EAAG,EAAKhB,EAAE,IAC5BiB,UAAW,CAAC/B,MAAO,IACnBgC,aAAc,CAAChC,MAAO,CAAC8B,EAAG,EAAGhB,EAAE,IAC/BmB,MAAO,CAACjC,OAAO,IAAIkC,EAAAA,KAAgB9C,KAAKe,EAAQ,SAGlDgC,EAAAA,IAAAA,MCvEO,k8xBDyEP,IAAMC,EAAW,IAAIC,EAAAA,IAAe,CAClCV,SAAU3C,KAAK2C,SACfW,aAAchB,EAAUiB,QACxBC,eAAgBlB,EAAUmB,QAC1BC,aAAa,EACbC,QAAS,KAGX3D,KAAK4D,KAAO,IAAIC,EAAAA,IAAKpB,EAAUW,GAC/B,IAAMU,EAAQ,IACd9D,KAAK4D,KAAKE,MAAMjD,IAAIiD,EAAOA,EAAOA,GAClCvB,EAAOlB,IAAIrB,KAAK4D,MAChB5D,KAAK+D,OAAS,GACdC,EAAAA,GAAAA,GAAQhE,KAAK4D,KAAKE,MAAO,CACvBhB,EAAG,GACHhB,EAAG,GACHC,EAAG,GACHkC,SAAU,IACVC,WAAY,WACVjD,EAAKkD,UACP,IAEFnE,KAAK4B,QAAS,CAChB,CAgCC,OAhCArB,EAAAA,EAAAA,GAAA+B,EAAA,EAAA9B,IAAA,WAAAQ,MAED,WACEhB,KAAK4D,KAAKrB,OAAO6B,OAAOpE,KAAK4D,MAC7B5D,KAAK+D,OAAS,GACd/D,KAAK4B,QAAS,EACd5B,KAAK4D,KAAKnB,SAAS4B,UACnBrE,KAAK4D,KAAKR,SAASiB,UACfrE,KAAKwC,WACPxC,KAAKwC,UAAU8B,gBAAgBtE,KAEnC,GAAC,CAAAQ,IAAA,SAAAQ,MAED,SAAOU,GACA1B,KAAK4B,SAGV5B,KAAK2C,SAASC,OAAO5B,OAASU,EAC9B1B,KAAK2C,SAASI,UAAU/B,MAAQhB,KAAK4D,KAAKR,SAASO,QAcrD,KAACrB,CAAA,CA5HY,GAATA,EACGiB,QAAO,skBADVjB,EAuBGmB,QAAO,23BEzB2B,IACrCc,EAAS,WACb,SAAAA,EAAYtE,IAAMF,EAAAA,EAAAA,GAAA,KAAAwE,GAChBvE,KAAKC,KAAOA,EACZD,KAAKG,MAAQF,EAAKE,MAClBH,KAAKwE,YACLxE,KAAKyE,WACLzE,KAAKK,OAAS,IAAIC,EAAAA,IAClBN,KAAK0E,WAAa,EACpB,CA2HC,OA3HAnE,EAAAA,EAAAA,GAAAgE,EAAA,EAAA/D,IAAA,YAAAQ,MAED,WAAa,IAADC,EAAA,MACK,IAAIC,EAAAA,GACZd,KAAKe,EAAQ,OAA8C,SAAAC,GAChEH,EAAK0D,KAAOvD,EAAKlB,MAAM0E,SAAS,GAChC3D,EAAK0D,KAAKE,KAAO,YACCnE,IAAdO,EAAK6D,MACP7D,EAAK8D,MAET,GACF,GAAC,CAAAvE,IAAA,WAAAQ,MAED,WAAY,IAADgE,EAAA,MACM,IAAI9D,EAAAA,GACZd,KAAKe,EAAQ,OAA8C,SAAAC,GAChE4D,EAAKF,KAAO1D,EAAKlB,MAAM0E,SAAS,QACdlE,IAAdsE,EAAKF,MACPE,EAAKD,MAET,GACF,GAAC,CAAAvE,IAAA,OAAAQ,MAED,WACEhB,KAAKwC,UAAY,GACjB,IAAMA,EAAY,IAAIyC,EAAAA,IACtBzC,EAAUnB,IAAIrB,KAAK2E,MACnB3E,KAAK8E,KAAK9C,SAASc,EAAe,IAAVb,KAAKiD,GAC7BlF,KAAK8E,KAAKrD,SAASK,EAAI,IACvBU,EAAUnB,IAAIrB,KAAK8E,MAEnB,IADA,IAAIK,GAAS,EACJrD,EAAI,IAAKA,GAAK,EAAGA,GAAK,IAE7B,GADAqD,GAAUA,EACA,IAANrD,EAAJ,CAGA,IAAMgD,EAAO9E,KAAK8E,KAAKM,QACvBN,EAAK9C,SAASc,EAAIqC,EAAoB,IAAVlD,KAAKiD,GAAW,EAC5CJ,EAAKrD,SAASK,EAAIA,EAClBU,EAAUnB,IAAIyD,EAJd,CAMF9E,KAAKwC,UAAU6C,KAAK7C,GACpBxC,KAAKG,MAAMkB,IAAImB,GAEf,IAAK,IAAI8C,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAMC,EAAa/C,EAAU4C,QAC7BpF,KAAKG,MAAMkB,IAAIkE,GACfvF,KAAKwC,UAAU6C,KAAKE,EACtB,CAEAvF,KAAKwF,OACP,GAAC,CAAAhF,IAAA,QAAAQ,MAED,WAAS,IAGHyE,EAHEC,EAAA,KAIF,IAHJ1F,KAAK2F,cAAgB,CAAEC,IAAK,GAAIC,OAAQ,GACxC7F,KAAKwC,UAAUsD,SAAQ,SAAAC,GAAQ,OAAIL,EAAKM,gBAAgBD,EAAS,IAEtD/F,KAAK0E,WAAWuB,OAAO,GAAKR,EAAM,KACrCzF,KAAK0E,WAAW,GAAGR,aACnBuB,GAEV,GAAC,CAAAjF,IAAA,kBAAAQ,MAED,SAAiBkF,GACf,IAAMC,EAAQnG,KAAK0E,WAAW0B,QAASF,IACzB,GAAVC,GAAanG,KAAK0E,WAAW0B,QAAQD,EAAO,EACpD,GAAC,CAAA3F,IAAA,kBAAAQ,MAEC,SAAgB+E,GACd/F,KAAK2F,cAAcC,KAAO,GAC1B,IAAMC,GAA0B,EAAhB5D,KAAKoE,SAAe,GAAKrG,KAAK2F,cAAcE,OAC5D7F,KAAK2F,cAAcE,QAAU,GAC7BE,EAAStE,SAASZ,IAAI,EAAGgF,EAAQ7F,KAAK2F,cAAcC,KACpDG,EAASnB,SAAS,GAAG5C,SAASF,EAAIG,KAAKoE,SAAWpE,KAAKiD,GAAK,EAC5Da,EAASO,SAASC,KAAM,EACxBR,EAASnB,SAASkB,SAAQ,SAAAU,GACxBA,EAAMzF,SAAU,CAClB,GACF,GAAC,CAAAP,IAAA,SAAAQ,MAED,SAAO4E,GAAM,IACPa,EADMC,EAAA,KAGV1G,KAAKwC,UAAUsD,SAAQ,SAAAC,GACrBA,EAASnB,SAAS,GAAG+B,QAAQ,KAC7B,IAAMC,EAAeb,EAAStE,SAASM,EAAI6D,EAAI7D,EAC3CE,KAAK4E,IAAID,GAAgB,IAAMb,EAASO,SAASC,MACnDE,EAAoBV,GAElBa,GAAgB,IAClBF,EAAKV,gBAAgBD,EAEzB,SAG0BrF,IAAtB+F,GACFA,EAAkB7B,SAASkC,MAAK,SAAAN,GAG9B,GAFAA,EAAM5F,iBAAiB8F,EAAKrG,QACfqG,EAAKrG,OAAO0G,kBAAkBnB,GAChC,EAGT,OAFAa,EAAkBH,SAASC,KAAM,EACjCG,EAAKH,IAAIC,IACF,CAEX,GAGJ,GAAC,CAAAhG,IAAA,MAAAQ,MAED,SAAIgG,GACc,QAAZA,EAAInC,MACNmC,EAAIjG,SAAU,EACdf,KAAKC,KAAKgH,aAEVjH,KAAK0E,WAAWW,KAAM,IAAI/C,EAAU0E,EAAKhH,OACzCA,KAAKC,KAAKiH,WAEd,GAAC,CAAA1G,IAAA,UAAAQ,MAED,WAAW,IACwBmG,EADzBC,GAAAC,EAAAA,EAAAA,GACWrH,KAAKwC,WAAS,IAAjC,IAAA4E,EAAAE,MAAAH,EAAAC,EAAAG,KAAAC,MAAmC,CAAC,IAAzBC,EAAIN,EAAAnG,MACbhB,KAAKG,MAAMiE,OAAOqD,EACpB,CAAC,OAAAC,GAAAN,EAAAO,EAAAD,EAAA,SAAAN,EAAAQ,GAAA,CACH,KAACrD,CAAA,CAnIY,G,SCITpE,EAAQ,IAAI0H,EAAAA,IACZC,EAAS,IAAID,EAAAA,IACf,GACAE,OAAOC,WAAWD,OAAOE,YACzB,IACA,KAGJH,EAAOrG,SAASZ,KAAK,KAAK,GAAG,MAC7BiH,EAAOI,OAAO,EAAG,EAAI,GACrB,IAAMC,EAAmB,IAAIN,EAAAA,IAC7BM,EAAiB9G,IAAIyG,GACrB,IAAMM,EAAe,IAAIP,EAAAA,IAAc,EAAG,EAAG,GAE7C1H,EAAMkB,IAAI8G,GAEV,IAAME,EAAU,IAAIR,EAAAA,IAAsB,SAAU,SAAU,GAC9DQ,EAAQ5G,SAASZ,IAAI,GAAK,EAAG,KAC7BV,EAAMkB,IAAIgH,GAEV,IAAMC,EAAW,IAAIT,EAAAA,IAKN,aACX,IACIU,EAAQ/F,EADNgG,EAAQ,IAAIX,EAAAA,IAEZ/H,EAAO,CACX+B,UAAS,EACTD,QAAQ,EACRzB,MAAAA,EACAsI,OAAQ,CAAC,GAELC,GAAYC,EAAAA,EAAAA,UAgDlB,SAASC,IACP,IAAMC,EAAO/I,EAAK2I,OAClB,IAAK,IAAMK,KAAKD,EACVA,EAAKC,IAAMD,EAAKC,GAAGC,WACrBF,EAAKC,GAAGE,MAGd,CAEA,SAASC,EAAUpE,GACjB,IAAMqE,EAAYpJ,EAAK2I,OAAO5D,QACZnE,IAAdwI,IACEA,EAAUH,WACZG,EAAUF,OAEZE,EAAUC,OAEd,CAEA,SAASlC,IACPnH,EAAKsJ,QACL,IAAMC,EAAMC,SAASC,eAAe,SAEhCzJ,EAAKsJ,MAAM,IAAI,GACjBtJ,EAAK0J,YAAc,EACnBP,EAAU,UAEVA,EAAU,SAGZI,EAAII,UAAY3J,EAAKsJ,MAAQtJ,EAAK0J,UACpC,CAEA,SAAStC,IACPpH,EAAK4J,QACOJ,SAASC,eAAe,SAChCE,UAAY3J,EAAK4J,MACjB5J,EAAK4J,OAAS,GAChBC,WAAWC,EAAU,MAEvBX,EAAU,YACZ,CAEA,SAASW,IACP9J,EAAK8B,QAAS,EACd,IAAMiI,EAAWP,SAASC,eAAe,YACnCO,EAAMR,SAASC,eAAe,WAEpCM,EAASE,MAAMC,QAAU,QACzBF,EAAIC,MAAMC,QAAU,QAEpBzB,EAAOxH,SAAU,EAEjB6H,IACAK,EAAU,WACZ,CAaA,SAASgB,IACPnK,EAAK+B,UAAW,CAClB,CAEA,SAASqI,IACPpK,EAAK+B,UAAW,CAClB,CAEA,SAASsI,EAAQxC,GACf,GACO,KADCA,EAAEyC,QAENtK,EAAK+B,UAAW,CAEtB,CACA,SAASwI,EAAM1C,GACb,GACO,KADCA,EAAEyC,QAENtK,EAAK+B,UAAW,CAEtB,CA+BA,SAASyI,IACP,IAAMC,EAAQxC,OAAOC,WACfwC,EAASzC,OAAOE,YAEtBH,EAAO2C,OAASF,EAAQC,EACxB1C,EAAO4C,yBACPpC,EAASqC,QAASJ,EAAOC,EAC3B,CAUA,SAASI,IACP,IAAMC,EAAKrC,EAAMsC,WACXpJ,EAAO8G,EAAMuC,iBACnBxC,EAAOyC,OAAOtJ,GACV5B,EAAK8B,QACPY,EAAUwI,OAAOzC,EAAO9G,SAAUoJ,GAZpC1C,EAAiB1G,SAASwJ,KAAM1C,EAAO9G,UACvC0G,EAAiB1G,SAASK,EAAI,EAC9BsG,EAAa6C,KAAK1C,EAAO9G,UACzB2G,EAAarG,GAAK,EAClB+F,EAAOI,OAAQE,GAWfE,EAAS4C,OAAO/K,EAAO2H,GACvBC,OAAOoD,sBAAsBP,EAC/B,CA6BA,OA5NAQ,EAAAA,EAAAA,YAAU,WAKR,OAJArD,OAAOsD,iBAAkB,SAAUf,GAAgB,GACnD5B,EAAU4C,QAAQC,YAAYjD,EAASkD,YAavC1L,EAAKmH,SAAWA,EAChBnH,EAAKoH,SAAWA,EAuIlB,WACE,IAAMuE,EAAS,IAAIC,EAAAA,EACbC,EAAiB,IAAI9D,EAAAA,IAAqBS,GAChDqD,EAAeC,+BACfH,EAAOrL,KAAKe,EAAQ,OAAwD,SAAA0K,GAC1E,IAAMC,EAASH,EAAeI,oBAAoBF,GAAGG,QACrDL,EAAetH,UACflE,EAAM8L,YAAcH,CACtB,QAAGpL,GAAW,SAAAiH,GACZuE,QAAQC,IAAI,OAAQxE,EACtB,GACF,CAjJEyE,GAuHAjM,EAAMkM,YAAa,IAAIxE,EAAAA,KACpBzH,KAAK,CACJe,EAAQ,MACRA,EAAQ,MACRA,EAAQ,MACRA,EAAQ,MACRA,EAAQ,MACRA,EAAQ,QAKZoH,EAAS,IAAI1I,EAAOC,GA5CpB0C,EAAY,IAAI+B,EAAUzE,GAI1BwJ,SAAS+B,iBAAiB,UAAWlB,GACrCb,SAAS+B,iBAAiB,QAAShB,GACnC3B,EAAU4C,QAAQD,iBAAiB,YAAapB,GAChDvB,EAAU4C,QAAQD,iBAAiB,UAAWnB,GAtFhD,WACE,IAAMoC,EAAO,CACX,CAACC,IAAK,YAAaC,KAAMrL,EAAQ,OACjC,CAACoL,IAAK,SAAUC,KAAMrL,EAAQ,KAAgDsL,MAAM,GACpF,CAACF,IAAK,QAASC,KAAMrL,EAAQ,OAC7B,CAACoL,IAAK,WAAYC,KAAMrL,EAAQ,MAChC,CAACoL,IAAK,QAASC,KAAMrL,EAAQ,QAEzBuL,EAAW,IAAI7E,EAAAA,IACrBC,EAAOzG,IAAIqL,GACXJ,EAAKxG,SAAS,SAAA6B,GACZ,IAAMgF,EAAQ,IAAI9E,EAAAA,IAAY6E,GAC9B5M,EAAK2I,OAAOd,EAAE4E,KAAOI,GACD,IAAI9E,EAAAA,KAAoBzH,KAAKuH,EAAE6E,MAAM,SAAA3D,GACvD8D,EAAMC,UAAU/D,GAChB8D,EAAME,UAAUlF,EAAE8E,MAClBE,EAAMG,UAAU,GAClB,GACF,GACF,CAtBEC,GAlBAnC,IACO,WACLtB,SAAS0D,oBAAoB,UAAW7C,GACxCb,SAAS0D,oBAAoB,QAAS3C,GACtCzB,IACAzI,EAAMiE,OAAOmE,EAAO5H,OACpB6B,EAAUyK,SACZ,CACF,GAAG,KAgNIC,EAAAA,EAAAA,MAAA,OAAAtI,SAAA,EACLuI,EAAAA,EAAAA,KAAA,KAAGC,UAAWC,EAAAA,aAAqBC,GAAG,eAAc1I,SAAC,wEACrDsI,EAAAA,EAAAA,MAAA,OAAKI,GAAG,OAAOF,UAAWC,EAAAA,KAAYzI,SAAA,EACpCsI,EAAAA,EAAAA,MAAA,OAAKI,GAAG,OAAOF,UAAWC,EAAAA,KAAYzI,SAAA,EACpCuI,EAAAA,EAAAA,KAAA,OAAKC,UAAWC,EAAAA,SAAiBE,IAAKpM,EAAQ,SAC9CgM,EAAAA,EAAAA,KAAA,OAAKG,GAAG,QAAQF,UAAWC,EAAAA,MAAazI,SAAC,UAE3CsI,EAAAA,EAAAA,MAAA,OAAKI,GAAG,cAAcF,UAAWC,EAAAA,YAAmBzI,SAAA,EAClDuI,EAAAA,EAAAA,KAAA,OAAKC,UAAWC,EAAAA,MAAcC,GAAG,QAAO1I,SAAC,OACzCuI,EAAAA,EAAAA,KAAA,OAAKC,UAAWC,EAAAA,SAAiBE,IAAKpM,EAAQ,eAGlDgM,EAAAA,EAAAA,KAAA,KAAGG,GAAG,WAAWF,UAAWC,EAAAA,SAAgBzI,SAAC,eAC7CuI,EAAAA,EAAAA,KAAA,UAAQC,UAAWC,EAAAA,QAAgBC,GAAG,UAAUE,QAxClD,WACI,IAAMC,EAAenE,SAASC,eAAe,gBACvCO,EAAMR,SAASC,eAAe,WACnBD,SAASC,eAAe,YAEhCQ,MAAMC,QAAU,OACzByD,EAAa1D,MAAMC,QAAU,OAC7BF,EAAIC,MAAMC,QAAU,OAEpBlK,EAAKsJ,MAAQ,EACbtJ,EAAK0J,WAAa,EAClB1J,EAAK4J,MAAQ,EAEDJ,SAASC,eAAe,SAChCE,UAAY3J,EAAKsJ,MACRE,SAASC,eAAe,SAChCE,UAAY3J,EAAK4J,MAGtBnB,EAAO/C,QACPhD,EAAUgD,QAEV1F,EAAK8B,QAAS,EAEdqH,EAAU,SACd,EAeiErE,SAAC,kBAChEuI,EAAAA,EAAAA,KAAA,OAAKO,IAAKhF,MAEd,CA3PFJ,EAASqF,cAAc5F,OAAO6F,kBAC9BtF,EAASuF,eAAiBhG,EAAAA,IAC1BS,EAASqC,QAAQ5C,OAAOC,WAAYD,OAAOE,Y,6peClBrCyD,EAAU,SAAAoC,IAAAC,EAAAA,EAAAA,GAAArC,EAAAoC,GAAA,IAAAE,GAAAC,EAAAA,EAAAA,GAAAvC,GAEf,SAAAA,EAAawC,GAAU,IAAAjN,EAII,OAJJlB,EAAAA,EAAAA,GAAA,KAAA2L,IAEtBzK,EAAA+M,EAAAG,KAAA,KAAOD,IAEFE,KAAOC,EAAAA,IAAcpN,CAE3B,CA2bC,OAzbDV,EAAAA,EAAAA,GAAAmL,EAAA,EAAAlL,IAAA,QAAAQ,MAEA,SAAOsN,GAEN,IAUCC,EAAa,SAAWC,EAAiBC,GAExC,OAASD,GAER,KARgB,EAQMtC,QAAQwC,MAAO,iCAAoCD,GAAO,KAC/E,MACD,KATiB,EASMvC,QAAQwC,MAAO,kCAAqCD,GAAO,KACjF,MACD,KAVkB,EAUMvC,QAAQwC,MAAO,sCAAyCD,GAAO,KACtF,MACD,QACwBvC,QAAQwC,MAAO,6BAAgCD,GAAO,KAI/E,OAtBqB,CAwBtB,EAiBAE,EAAQ,SAAWL,EAAQM,EAAWC,GAIrCD,EAAcA,GAAY,KAK1B,IAJA,IAAIE,EAAIR,EAAO1I,IACdN,GAAM,EAAGyJ,EAAM,EAAGzH,EAAI,GACtB0H,EAAQC,OAAOC,aAAaC,MAAO,KAAM,IAAIC,YAAad,EAAOe,SAAUP,EAAGA,EAL7D,OAOR,GAAMxJ,EAAI0J,EAAM5I,QAXjB,QAW6C2I,EAAMH,GAAiBE,EAAIR,EAAOgB,YAEvFhI,GAAK0H,EAAOD,GAAOC,EAAM/I,OACzB6I,GAViB,IAWjBE,GAASC,OAAOC,aAAaC,MAAO,KAAM,IAAIC,YAAad,EAAOe,SAAUP,EAAGA,EAX9D,OAelB,OAAO,EAAIxJ,KAQL,IAAUuJ,IAAUP,EAAO1I,KAAOmJ,EAAMzJ,EAAI,GAC1CgC,EAAI0H,EAAMO,MAAO,EAAGjK,GAM7B,EAyOKkK,EAAqB,SAAWC,EAAaC,EAAcC,EAAWC,GAE3E,IAAMjI,EAAI8H,EAAaC,EAAe,GAChC5L,EAAQ7B,KAAK4N,IAAK,EAAKlI,EAAI,KAAU,IAE3CgI,EAAWC,EAAa,GAAMH,EAAaC,EAAe,GAAM5L,EAChE6L,EAAWC,EAAa,GAAMH,EAAaC,EAAe,GAAM5L,EAChE6L,EAAWC,EAAa,GAAMH,EAAaC,EAAe,GAAM5L,EAChE6L,EAAWC,EAAa,GAAM,CAE/B,EAEME,EAAoB,SAAWL,EAAaC,EAAcC,EAAWC,GAE1E,IAAMjI,EAAI8H,EAAaC,EAAe,GAChC5L,EAAQ7B,KAAK4N,IAAK,EAAKlI,EAAI,KAAU,IAG3CgI,EAAWC,EAAa,GAAMG,EAAAA,IAAAA,YAAuB9N,KAAK+N,IAAKP,EAAaC,EAAe,GAAM5L,EAAO,QACxG6L,EAAWC,EAAa,GAAMG,EAAAA,IAAAA,YAAuB9N,KAAK+N,IAAKP,EAAaC,EAAe,GAAM5L,EAAO,QACxG6L,EAAWC,EAAa,GAAMG,EAAAA,IAAAA,YAAuB9N,KAAK+N,IAAKP,EAAaC,EAAe,GAAM5L,EAAO,QACxG6L,EAAWC,EAAa,GAAMG,EAAAA,IAAAA,YAAuB,EAEtD,EAEME,EAAY,IAAIC,WAAY5B,GAClC2B,EAAUrK,IAAM,EAChB,IAAMuK,EAjQa,SAAW7B,GAI5B,IA2BI8B,EAAMC,EA1BTC,EAAW,oCACXC,EAAc,uCACdC,EAAY,uBACZC,EAAgB,oCAGhBC,EAAS,CAERC,MAAO,EAEPC,OAAQ,GAERC,SAAU,GAEVC,YAAa,OAEbC,OAAQ,GAERC,MAAO,EAEPC,SAAU,EAEV1G,MAAO,EAAGC,OAAQ,GAMpB,GAAK8D,EAAO1I,KAAO0I,EAAOgB,cAAkBc,EAAOzB,EAAOL,IAEzD,OAAOC,EA5GS,EA4GoB,mBAKrC,KAAS8B,EAAQD,EAAKC,MApCC,cAsCtB,OAAO9B,EAjHW,EAiHoB,qBAQvC,IAJAmC,EAAOC,OAvFiB,EAwFxBD,EAAOI,YAAcT,EAAO,GAC5BK,EAAOE,QAAUR,EAAO,MAKlB,KADLA,EAAOzB,EAAOL,KAId,GAFAoC,EAAOE,QAAUR,EAAO,KAEnB,MAAQA,EAAKc,OAAQ,IAkC1B,IA3BKb,EAAQD,EAAKC,MAAOC,MAExBI,EAAOM,MAAQG,WAAYd,EAAO,MAI9BA,EAAQD,EAAKC,MAAOE,MAExBG,EAAOO,SAAWE,WAAYd,EAAO,MAIjCA,EAAQD,EAAKC,MAAOG,MAExBE,EAAOC,OArHU,EAsHjBD,EAAOK,OAASV,EAAO,KAInBA,EAAQD,EAAKC,MAAOI,MAExBC,EAAOC,OA3Hc,EA4HrBD,EAAOlG,OAAS4G,SAAUf,EAAO,GAAK,IACtCK,EAAOnG,MAAQ6G,SAAUf,EAAO,GAAK,KA9HpB,EAkIXK,EAAOC,OAjIQ,EAiIyBD,EAAOC,MAAkC,WAhCvFD,EAAOG,UAAYT,EAAO,KAoC5B,OAtImB,EAsIVM,EAAOC,MArIO,EA2IdD,EAAOC,MAMTD,EAJCnC,EA7KW,EA6KoB,gCAN/BA,EAvKW,EAuKoB,2BAYxC,CAqJwB8C,CAAiBpB,GAE1C,IA/UuB,IA+UME,EAAmB,CAE/C,IAAMmB,EAAInB,EAAiB5F,MAC1BgH,EAAIpB,EAAiB3F,OACrBgH,EAzJqB,SAAWlD,EAAQgD,EAAGC,GAE3C,IAAME,EAAiBH,EAEvB,GAEKG,EAAiB,GAASA,EAAiB,OAE3C,IAAMnD,EAAQ,IAAW,IAAMA,EAAQ,IAAyB,IAAdA,EAAQ,GAI9D,OAAO,IAAI4B,WAAY5B,GAIxB,GAAKmD,KAAuBnD,EAAQ,IAAO,EAAMA,EAAQ,IAExD,OAAOC,EAvMW,EAuMoB,wBAIvC,IAAMmD,EAAY,IAAIxB,WAAY,EAAIoB,EAAIC,GAE1C,IAAOG,EAAUzL,OAEhB,OAAOsI,EA9MW,EA8MoB,mCAYvC,IARA,IAAI1I,EAAS,EAAGD,EAAM,EAEhB+L,EAAU,EAAIF,EACdG,EAAY,IAAI1B,WAAY,GAC5B2B,EAAkB,IAAI3B,WAAYyB,GACpCG,EAAgBP,EAGVO,EAAgB,GAASlM,EAAM0I,EAAOgB,YAAe,CAE9D,GAAK1J,EAAM,EAAI0I,EAAOgB,WAErB,OAAOf,EAjOQ,GA0OhB,GALAqD,EAAW,GAAMtD,EAAQ1I,KACzBgM,EAAW,GAAMtD,EAAQ1I,KACzBgM,EAAW,GAAMtD,EAAQ1I,KACzBgM,EAAW,GAAMtD,EAAQ1I,KAElB,GAAKgM,EAAW,IAAW,GAAKA,EAAW,KAAeA,EAAW,IAAO,EAAMA,EAAW,KAASH,EAE5G,OAAOlD,EA1OU,EA0OqB,4BAQvC,IAFA,IAAIwD,EAAM,EAAGtM,OAAK,EAERsM,EAAMJ,GAAe/L,EAAM0I,EAAOgB,YAAe,CAG1D,IAAM0C,GADNvM,EAAQ6I,EAAQ1I,MACa,IAG7B,GAFKoM,IAAevM,GAAS,KAEtB,IAAMA,GAAasM,EAAMtM,EAAQkM,EAEvC,OAAOpD,EA1PS,EA0PsB,qBAIvC,GAAKyD,EAIJ,IADA,IAAMC,EAAY3D,EAAQ1I,KAChBN,EAAI,EAAGA,EAAIG,EAAOH,IAE3BuM,EAAiBE,KAAWE,OAQ7BJ,EAAgBhR,IAAKyN,EAAOe,SAAUzJ,EAAKA,EAAMH,GAASsM,GAC1DA,GAAOtM,EAAOG,GAAOH,CAIvB,CAMA,IADA,IAAMyM,EAAIT,EACAnM,EAAI,EAAGA,EAAI4M,EAAG5M,IAAO,CAE9B,IAAI6M,EAAM,EACVT,EAAW7L,GAAWgM,EAAiBvM,EAAI6M,GAC3CA,GAAOV,EACPC,EAAW7L,EAAS,GAAMgM,EAAiBvM,EAAI6M,GAC/CA,GAAOV,EACPC,EAAW7L,EAAS,GAAMgM,EAAiBvM,EAAI6M,GAC/CA,GAAOV,EACPC,EAAW7L,EAAS,GAAMgM,EAAiBvM,EAAI6M,GAC/CtM,GAAU,CAEX,CAEAiM,GAED,CAEA,OAAOJ,CAER,CAmCmBU,CAAqBnC,EAAUZ,SAAUY,EAAUrK,KAAO0L,EAAGC,GAEhF,IArVsB,IAqVOC,EAAkB,CAE9C,IAAI3I,EAAMuF,EACNiE,EAEJ,OAASrS,KAAKoO,MAEb,KAAKkE,EAAAA,IAEJD,EAAcb,EAAgBvL,OAAS,EAGvC,IAFA,IAAMsM,EAAa,IAAIC,aAA4B,EAAdH,GAE3BI,EAAI,EAAGA,EAAIJ,EAAaI,IAEjCjD,EAAoBgC,EAAqB,EAAJiB,EAAOF,EAAgB,EAAJE,GAIzD5J,EAAO0J,EACPnE,EAAOkE,EAAAA,IACP,MAED,KAAKjE,EAAAA,IAEJgE,EAAcb,EAAgBvL,OAAS,EAGvC,IAFA,IAAMyM,EAAY,IAAItD,YAA2B,EAAdiD,GAEzBI,EAAI,EAAGA,EAAIJ,EAAaI,IAEjC3C,EAAmB0B,EAAqB,EAAJiB,EAAOC,EAAe,EAAJD,GAIvD5J,EAAO6J,EACPtE,EAAOC,EAAAA,IACP,MAED,QAECnC,QAAQwC,MAAO,uCAAwC1O,KAAKoO,MAK9D,MAAO,CACN7D,MAAO+G,EAAG9G,OAAQ+G,EAClB1I,KAAMA,EACN6H,OAAQP,EAAiBS,OACzBI,MAAOb,EAAiBa,MACxBC,SAAUd,EAAiBc,SAC3B7C,KAAMA,EAGR,CAED,CAEA,OAAO,IAER,GAAC,CAAA5N,IAAA,cAAAQ,MAED,SAAaA,GAGZ,OADAhB,KAAKoO,KAAOpN,EACLhB,IAER,GAAC,CAAAQ,IAAA,OAAAQ,MAED,SAAM2R,EAAKC,EAAQC,EAAYC,GAuB9B,OAAAC,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,GAAAtH,EAAAuH,WAAA,aAAA9E,KAAA,KAAmBwE,GArBnB,SAAyB3G,EAASkH,GAEjC,OAASlH,EAAQoC,MAEhB,KAAKkE,EAAAA,IACL,KAAKjE,EAAAA,IAEJrC,EAAQmH,SAAWC,EAAAA,IACnBpH,EAAQqH,UAAYC,EAAAA,IACpBtH,EAAQuH,UAAYD,EAAAA,IACpBtH,EAAQwH,iBAAkB,EAC1BxH,EAAQyH,OAAQ,EAMbb,GAASA,EAAQ5G,EAASkH,EAEhC,GAEwCL,EAAYC,EAErD,KAACpH,CAAA,CAncc,CAASgI,EAAAA,I","sources":["practice/game/plane/Player.js","webpack://three/./src/practice/game/plane/plane.module.css?d1e3","practice/game/plane/Explosion.js","libs/shader/Noise.js","practice/game/plane/Obstacles.js","practice/game/plane/main.js","../node_modules/three/examples/jsm/loaders/RGBELoader.js"],"sourcesContent":["import { Vector3 } from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\r\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\r\n\r\nclass Player {\r\n  constructor(info) {\r\n    this.game = info;\r\n    this.scene = info.sence\r\n    this.load()\r\n    this.tmpPos = new Vector3()\r\n  }\r\n\r\n  get position() {\r\n    if (this.plane !== undefined) {\r\n      this.plane.getWorldPosition(this.tmpPos)\r\n    }\r\n    return this.tmpPos\r\n  }\r\n\r\n  set visible(mode) {\r\n    this.plane.visible = mode\r\n  }\r\n\r\n  load() {\r\n    const loader = new GLTFLoader()\r\n    loader.load(require(\"../../../assets/gameSource/plane/microplane.glb\"), gltf => {\r\n      this.scene.add(gltf.scene)\r\n      this.plane = gltf.scene\r\n      // 螺旋桨\r\n      this.propeller = this.plane.getObjectByName(\"propeller\");\r\n      this.velocity = new Vector3(0, 0 , 0.1)\r\n\r\n    })\r\n  }\r\n\r\n  reset() {\r\n    this.plane.position.set(0, 0, 0);\r\n    this.plane.visible = true;\r\n    this.velocity.set(0,0,0.1);\r\n  }\r\n\r\n  update(time) {\r\n    if (!this.plane) {\r\n      return\r\n    }\r\n    if (this.propeller !== undefined) {\r\n      this.propeller.rotateZ(1)\r\n    }\r\n    if (this.game.active) {\r\n      if (!this.game.spaceKey) {\r\n        this.velocity.y -= 0.001\r\n      } else {\r\n        this.velocity.y += 0.001\r\n      }\r\n      this.velocity.z += 0.0001\r\n      this.plane.rotation.set(0, 0, Math.sin(time * 3)*0.2, 'XYZ')\r\n      this.plane.translateZ(this.velocity.z)\r\n      this.plane.translateY(this.velocity.y)\r\n    } else {\r\n      this.plane.rotation.set(0, 0, Math.sin(time*3)*0.2, 'XYZ')\r\n      this.plane.position.y = Math.cos(time) * 1.5\r\n    }\r\n  }\r\n}\r\n\r\nexport { Player }","// extracted by mini-css-extract-plugin\nexport default {\"playBtn\":\"plane_playBtn__wHmK2\",\"instructions\":\"plane_instructions__OozWy\",\"gameover\":\"plane_gameover__CbUXp\",\"info\":\"plane_info__PnVIV\",\"info_img\":\"plane_info_img__ZQ4W3\",\"life\":\"plane_life__K67Q1\",\"score_panel\":\"plane_score_panel__8TOBV\",\"lives\":\"plane_lives__VlEOx\",\"score\":\"plane_score__lnFNi\"};","import { IcosahedronGeometry, TextureLoader, ShaderMaterial, Mesh, ShaderChunk } from 'three';\r\nimport {noise} from '../../../libs/shader/Noise'\r\nimport { gsap } from 'gsap';\r\n\r\nclass Explosion {\r\n  static vshader = `\r\n#include <noise>\r\n\r\nuniform float u_time;\r\n\r\nvarying float noise;\r\n\r\nvoid main() {\t\r\n  float time = u_time;\r\n  float displacement;\r\n  float b;\r\n  \r\n  // add time to the noise parameters so it's animated\r\n  noise = 10.0 *  -.10 * turbulence( .5 * normal + time );\r\n  b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );\r\n  displacement = - 10. * noise + b;\r\n\r\n  // move the position along the normal and transform it\r\n  vec3 newPosition = position + normal * displacement;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\r\n}\r\n`\r\n  static fshader = `\r\n#define PI 3.141592653589\r\n#define PI2 6.28318530718\r\n\r\nuniform vec2 u_mouse;\r\nuniform vec2 u_resolution;\r\nuniform float u_time;\r\nuniform float u_opacity;\r\nuniform sampler2D u_tex;\r\n\r\nvarying float noise;\r\n\r\n//\t<https://www.shadertoy.com/view/4dS3Wd>\r\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\r\n\r\n//https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/\r\n\r\nfloat random( vec3 scale, float seed ){\r\n  return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;\r\n}\r\n\r\nvoid main() {\r\n\r\n  // get a random offset\r\n  float r = .01 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\r\n  // lookup vertically in the texture, using noise and offset\r\n  // to get the right RGB colour\r\n  vec2 t_pos = vec2( 0, 1.3 * noise + r );\r\n  vec4 color = texture2D( u_tex, t_pos );\r\n\r\n  gl_FragColor = vec4( color.rgb, u_opacity );\r\n}\r\n`\r\n  constructor(parent, obstacles) {\r\n    const geometry = new IcosahedronGeometry(20, 4)\r\n    this.obstacles = obstacles\r\n    this.uniforms = {\r\n      u_time: {value: 0.0},\r\n      u_mouse: {value: {x: 0.0, y:0.0}},\r\n      u_opacity: {value: 0.6},\r\n      u_resolution: {value: {x: 0, y:0}},\r\n      u_tex: {value: new TextureLoader().load(require(\"../../../assets/gameSource/plane/explosion.png\"))}\r\n    }\r\n\r\n    ShaderChunk.noise = noise\r\n\r\n    const material = new ShaderMaterial({\r\n      uniforms: this.uniforms,\r\n      vertexShader: Explosion.vshader,\r\n      fragmentShader: Explosion.fshader,\r\n      transparent: true,\r\n      opacity: 0.6\r\n    })\r\n\r\n    this.ball = new Mesh(geometry, material)\r\n    const scale = 0.05\r\n    this.ball.scale.set(scale, scale, scale)\r\n    parent.add(this.ball)\r\n    this.tweens = []\r\n    gsap.to(this.ball.scale, {\r\n      x: 0.2,\r\n      y: 0.2,\r\n      z: 0.2, \r\n      duration: 1.5,\r\n      onComplete: () => {\r\n        this.complete()\r\n      }\r\n    })\r\n    this.active = true\r\n  }\r\n\r\n  complete() {\r\n    this.ball.parent.remove(this.ball)\r\n    this.tweens = []\r\n    this.active = false\r\n    this.ball.geometry.dispose()\r\n    this.ball.material.dispose()\r\n    if (this.obstacles) {\r\n      this.obstacles.removeExplosion(this)\r\n    }\r\n  }\r\n\r\n  update(time) {\r\n    if (!this.active) {\r\n      return\r\n    }\r\n    this.uniforms.u_time.value += time\r\n    this.uniforms.u_opacity.value = this.ball.material.opacity\r\n    // if (this.tweens.length < 2) {\r\n    //   const elapsedTime = this.uniforms.u_time.value -1\r\n    //   if (elapsedTime > 0) {\r\n    //     gsap.to(this.ball.material, {\r\n    //       opacity: 0,\r\n    //       duration: 0.5\r\n    //     })\r\n    //     // g.pause()\r\n    //     // this.tweens.push(g)\r\n    //   }\r\n    // }\r\n\r\n    // this.tweens.forEach( e => )\r\n  }\r\n}\r\n\r\nexport {Explosion}","const noise = `\n\t//\n\t// Description : Array and textureless GLSL 2D/3D/4D simplex \n\t//               noise functions.\n\t//      Author : Ian McEwan, Ashima Arts.\n\t//  Maintainer : stegu\n\t//     Lastmod : 20110822 (ijm)\n\t//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\t//               Distributed under the MIT License. See LICENSE file.\n\t//               https://github.com/ashima/webgl-noise\n\t//               https://github.com/stegu/webgl-noise\n\t// \n\n\tvec3 mod289(vec3 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 mod289(vec4 x) {\n\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec4 permute(vec4 x) {\n\t\t return mod289(((x*34.0)+1.0)*x);\n\t}\n\n\t// Permutation polynomial (ring size 289 = 17*17)\n\tvec3 permute(vec3 x) {\n\t  return mod289(((x*34.0)+1.0)*x);\n\t}\n\t\n\tfloat permute(float x){\n\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;;\n\t}\n\n\tvec4 taylorInvSqrt(vec4 r){\n\t  return 1.79284291400159 - 0.85373472095314 * r;\n\t}\n\n\tvec2 fade(vec2 t) {\n\t  return t*t*t*(t*(t*6.0-15.0)+10.0);\n\t}\n\n\tvec3 fade(vec3 t) {\n\t  return t*t*t*(t*(t*6.0-15.0)+10.0);\n\t}\n\t\n\t// Hashed 2-D gradients with an extra rotation.\n\t// (The constant 0.0243902439 is 1/41)\n\tvec2 rgrad2(vec2 p, float rot) {\n\t#if 0\n\t// Map from a line to a diamond such that a shift maps to a rotation.\n\t  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n\t  u = 4.0 * fract(u) - 2.0;\n\t  // (This vector could be normalized, exactly or approximately.)\n\t  return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);\n\t#else\n\t// For more isotropic gradients, sin/cos can be used instead.\n\t  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n\t  u = fract(u) * 6.28318530718; // 2*pi\n\t  return vec2(cos(u), sin(u));\n\t#endif\n\t}\n\n\tfloat snoise(vec3 v){ \n\t  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\t  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\t  vec3 i  = floor(v + dot(v, C.yyy) );\n\t  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\t  vec3 g = step(x0.yzx, x0.xyz);\n\t  vec3 l = 1.0 - g;\n\t  vec3 i1 = min( g.xyz, l.zxy );\n\t  vec3 i2 = max( g.xyz, l.zxy );\n\n\t  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t  //   x1 = x0 - i1  + 1.0 * C.xxx;\n\t  //   x2 = x0 - i2  + 2.0 * C.xxx;\n\t  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t  vec3 x1 = x0 - i1 + C.xxx;\n\t  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\t  i = mod289(i); \n\t  vec4 p = permute( permute( permute( \n\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t  float n_ = 0.142857142857; // 1.0/7.0\n\t  vec3  ns = n_ * D.wyz - D.xzx;\n\n\t  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\t  vec4 x_ = floor(j * ns.z);\n\t  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t  vec4 h = 1.0 - abs(x) - abs(y);\n\n\t  vec4 b0 = vec4( x.xy, y.xy );\n\t  vec4 b1 = vec4( x.zw, y.zw );\n\n\t  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t  vec4 sh = -step(h, vec4(0.0));\n\n\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\t  vec3 p0 = vec3(a0.xy,h.x);\n\t  vec3 p1 = vec3(a0.zw,h.y);\n\t  vec3 p2 = vec3(a1.xy,h.z);\n\t  vec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t  p0 *= norm.x;\n\t  p1 *= norm.y;\n\t  p2 *= norm.z;\n\t  p3 *= norm.w;\n\n\t// Mix final noise value\n\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t  m = m * m;\n\t  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n\t  }\n\n\t// Classic Perlin noise\n\tfloat cnoise(vec2 P){\n\t  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\t  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\t  Pi = mod289(Pi); // To avoid truncation effects in permutation\n\t  vec4 ix = Pi.xzxz;\n\t  vec4 iy = Pi.yyww;\n\t  vec4 fx = Pf.xzxz;\n\t  vec4 fy = Pf.yyww;\n\n\t  vec4 i = permute(permute(ix) + iy);\n\n\t  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n\t  vec4 gy = abs(gx) - 0.5 ;\n\t  vec4 tx = floor(gx + 0.5);\n\t  gx = gx - tx;\n\n\t  vec2 g00 = vec2(gx.x,gy.x);\n\t  vec2 g10 = vec2(gx.y,gy.y);\n\t  vec2 g01 = vec2(gx.z,gy.z);\n\t  vec2 g11 = vec2(gx.w,gy.w);\n\n\t  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\t  g00 *= norm.x;  \n\t  g01 *= norm.y;  \n\t  g10 *= norm.z;  \n\t  g11 *= norm.w;  \n\n\t  float n00 = dot(g00, vec2(fx.x, fy.x));\n\t  float n10 = dot(g10, vec2(fx.y, fy.y));\n\t  float n01 = dot(g01, vec2(fx.z, fy.z));\n\t  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n\t  vec2 fade_xy = fade(Pf.xy);\n\t  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\t  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\t  return 2.3 * n_xy;\n\t}\n\n\t// Classic Perlin noise, periodic variant\n\tfloat pnoise(vec2 P, vec2 rep){\n\t  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\t  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\t  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n\t  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n\t  vec4 ix = Pi.xzxz;\n\t  vec4 iy = Pi.yyww;\n\t  vec4 fx = Pf.xzxz;\n\t  vec4 fy = Pf.yyww;\n\n\t  vec4 i = permute(permute(ix) + iy);\n\n\t  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n\t  vec4 gy = abs(gx) - 0.5 ;\n\t  vec4 tx = floor(gx + 0.5);\n\t  gx = gx - tx;\n\n\t  vec2 g00 = vec2(gx.x,gy.x);\n\t  vec2 g10 = vec2(gx.y,gy.y);\n\t  vec2 g01 = vec2(gx.z,gy.z);\n\t  vec2 g11 = vec2(gx.w,gy.w);\n\n\t  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\t  g00 *= norm.x;  \n\t  g01 *= norm.y;  \n\t  g10 *= norm.z;  \n\t  g11 *= norm.w;  \n\n\t  float n00 = dot(g00, vec2(fx.x, fy.x));\n\t  float n10 = dot(g10, vec2(fx.y, fy.y));\n\t  float n01 = dot(g01, vec2(fx.z, fy.z));\n\t  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n\t  vec2 fade_xy = fade(Pf.xy);\n\t  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\t  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\t  return 2.3 * n_xy;\n\t}\n\t// Classic Perlin noise\n\tfloat cnoise(vec3 P)\n\t{\n\t  vec3 Pi0 = floor(P); // Integer part for indexing\n\t  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n\t  Pi0 = mod289(Pi0);\n\t  Pi1 = mod289(Pi1);\n\t  vec3 Pf0 = fract(P); // Fractional part for interpolation\n\t  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\t  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t  vec4 iz0 = Pi0.zzzz;\n\t  vec4 iz1 = Pi1.zzzz;\n\n\t  vec4 ixy = permute(permute(ix) + iy);\n\t  vec4 ixy0 = permute(ixy + iz0);\n\t  vec4 ixy1 = permute(ixy + iz1);\n\n\t  vec4 gx0 = ixy0 * (1.0 / 7.0);\n\t  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\t  gx0 = fract(gx0);\n\t  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\t  vec4 sz0 = step(gz0, vec4(0.0));\n\t  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\t  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\t  vec4 gx1 = ixy1 * (1.0 / 7.0);\n\t  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\t  gx1 = fract(gx1);\n\t  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\t  vec4 sz1 = step(gz1, vec4(0.0));\n\t  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\t  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n\t  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n\t  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n\t  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n\t  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n\t  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n\t  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n\t  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n\t  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n\t  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\t  g000 *= norm0.x;\n\t  g010 *= norm0.y;\n\t  g100 *= norm0.z;\n\t  g110 *= norm0.w;\n\t  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\t  g001 *= norm1.x;\n\t  g011 *= norm1.y;\n\t  g101 *= norm1.z;\n\t  g111 *= norm1.w;\n\n\t  float n000 = dot(g000, Pf0);\n\t  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\t  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\t  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\t  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\t  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\t  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\t  float n111 = dot(g111, Pf1);\n\n\t  vec3 fade_xyz = fade(Pf0);\n\t  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\t  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\t  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n\t  return 2.2 * n_xyz;\n\t}\n\n\t// Classic Perlin noise, periodic variant\n\tfloat pnoise(vec3 P, vec3 rep)\n\t{\n\t  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n\t  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n\t  Pi0 = mod289(Pi0);\n\t  Pi1 = mod289(Pi1);\n\t  vec3 Pf0 = fract(P); // Fractional part for interpolation\n\t  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\t  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t  vec4 iz0 = Pi0.zzzz;\n\t  vec4 iz1 = Pi1.zzzz;\n\n\t  vec4 ixy = permute(permute(ix) + iy);\n\t  vec4 ixy0 = permute(ixy + iz0);\n\t  vec4 ixy1 = permute(ixy + iz1);\n\n\t  vec4 gx0 = ixy0 * (1.0 / 7.0);\n\t  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\t  gx0 = fract(gx0);\n\t  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\t  vec4 sz0 = step(gz0, vec4(0.0));\n\t  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\t  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\t  vec4 gx1 = ixy1 * (1.0 / 7.0);\n\t  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\t  gx1 = fract(gx1);\n\t  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\t  vec4 sz1 = step(gz1, vec4(0.0));\n\t  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\t  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n\t  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n\t  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n\t  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n\t  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n\t  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n\t  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n\t  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n\t  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n\t  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\t  g000 *= norm0.x;\n\t  g010 *= norm0.y;\n\t  g100 *= norm0.z;\n\t  g110 *= norm0.w;\n\t  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\t  g001 *= norm1.x;\n\t  g011 *= norm1.y;\n\t  g101 *= norm1.z;\n\t  g111 *= norm1.w;\n\n\t  float n000 = dot(g000, Pf0);\n\t  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\t  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\t  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\t  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\t  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\t  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\t  float n111 = dot(g111, Pf1);\n\n\t  vec3 fade_xyz = fade(Pf0);\n\t  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\t  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\t  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n\t  return 2.2 * n_xyz;\n\t}\n\t\n\tfloat turbulence( vec3 p ) {\n\t  float w = 100.0;\n\t  float t = -.5;\n\n\t  for (float f = 1.0 ; f <= 10.0 ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\n\t  }\n\n\t  return t;\n\t}\n\t\n\tfloat turbulence3( vec3 p ) {\n\t  float w = 100.0;\n\t  float t = -.5;\n\n\t  for (float f = 1.0 ; f <= 3.0 ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( pnoise( vec3( power * p ), vec3( 3.0, 3.0, 3.0 ) ) / power );\n\t  }\n\n\t  return t;\n\t}\n\t\n\tfloat turbulence6( vec3 p ) {\n\t  float w = 100.0;\n\t  float t = -.5;\n\n\t  for (float f = 1.0 ; f <= 6.0 ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( pnoise( vec3( power * p ), vec3( 6.0, 6.0, 6.0 ) ) / power );\n\t  }\n\n\t  return t;\n\t}\n\t\n\t//\n\t// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n\t// The first component of the 3-element return vector is the noise value,\n\t// and the second and third components are the x and y partial derivatives.\n\t//\n\tvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n\t  // Hack: offset y slightly to hide some rare artifacts\n\t  pos.y += 0.01;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n\t  // wrap points in (x,y), map to (u,v)\n\t  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n\t  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n\t  vec3 iuw = xw + 0.5 * yw;\n\t  vec3 ivw = yw;\n  \n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Partial derivatives for analytical gradient computation\n\t  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n\t  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  if (t.x < 0.0) {\n\t\tdtdx.x = 0.0;\n\t\tdtdy.x = 0.0;\n\t\tt.x = 0.0;\n\t  }\n\t  if (t.y < 0.0) {\n\t\tdtdx.y = 0.0;\n\t\tdtdy.y = 0.0;\n\t\tt.y = 0.0;\n\t  }\n\t  if (t.z < 0.0) {\n\t\tdtdx.z = 0.0;\n\t\tdtdy.z = 0.0;\n\t\tt.z = 0.0;\n\t  }\n\n\t  // Fourth power of t (and third power for derivative)\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n\t  vec3 t3 = t2 * t;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Final analytical derivative (gradient of a sum of scalar products)\n\t  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n\t  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n\t  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n\t  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n\t  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n\t  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n\t  return 11.0*vec3(n, dn0 + dn1 + dn2);\n\t}\n\n\t//\n\t// 2-D tiling simplex noise with fixed gradients\n\t// and analytical derivative.\n\t// This function is implemented as a wrapper to \"psrdnoise\",\n\t// at the minimal cost of three extra additions.\n\t//\n\tvec3 psdnoise(vec2 pos, vec2 per) {\n\t  return psrdnoise(pos, per, 0.0);\n\t}\n\n\t//\n\t// 2-D tiling simplex noise with rotating gradients,\n\t// but without the analytical derivative.\n\t//\n\tfloat psrnoise(vec2 pos, vec2 per, float rot) {\n\t  // Offset y slightly to hide some rare artifacts\n\t  pos.y += 0.001;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n\t  // wrap points in (x,y), map to (u,v)\n\t  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n\t  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n\t  vec3 iuw = xw + 0.5 * yw;\n\t  vec3 ivw = yw;\n  \n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  t = max(t, 0.0);\n\n\t  // Fourth power of t\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Rescale to cover the range [-1,1] reasonably well\n\t  return 11.0*n;\n\t}\n\n\t//\n\t// 2-D tiling simplex noise with fixed gradients,\n\t// without the analytical derivative.\n\t// This function is implemented as a wrapper to \"psrnoise\",\n\t// at the minimal cost of three extra additions.\n\t//\n\tfloat psnoise(vec2 pos, vec2 per) {\n\t  return psrnoise(pos, per, 0.0);\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n\t// The first component of the 3-element return vector is the noise value,\n\t// and the second and third components are the x and y partial derivatives.\n\t//\n\tvec3 srdnoise(vec2 pos, float rot) {\n\t  // Offset y slightly to hide some rare artifacts\n\t  pos.y += 0.001;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  vec3 x = vec3(p0.x, p1.x, p2.x);\n\t  vec3 y = vec3(p0.y, p1.y, p2.y);\n\t  vec3 iuw = x + 0.5 * y;\n\t  vec3 ivw = y;\n  \n\t  // Avoid precision issues in permutation\n\t  iuw = mod289(iuw);\n\t  ivw = mod289(ivw);\n\n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Partial derivatives for analytical gradient computation\n\t  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n\t  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  if (t.x < 0.0) {\n\t\tdtdx.x = 0.0;\n\t\tdtdy.x = 0.0;\n\t\tt.x = 0.0;\n\t  }\n\t  if (t.y < 0.0) {\n\t\tdtdx.y = 0.0;\n\t\tdtdy.y = 0.0;\n\t\tt.y = 0.0;\n\t  }\n\t  if (t.z < 0.0) {\n\t\tdtdx.z = 0.0;\n\t\tdtdy.z = 0.0;\n\t\tt.z = 0.0;\n\t  }\n\n\t  // Fourth power of t (and third power for derivative)\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n\t  vec3 t3 = t2 * t;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Final analytical derivative (gradient of a sum of scalar products)\n\t  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n\t  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n\t  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n\t  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n\t  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n\t  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n\t  return 11.0*vec3(n, dn0 + dn1 + dn2);\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n\t// This function is implemented as a wrapper to \"srdnoise\",\n\t// at the minimal cost of three extra additions.\n\t//\n\tvec3 sdnoise(vec2 pos) {\n\t  return srdnoise(pos, 0.0);\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with rotating gradients,\n\t// without the analytical derivative.\n\t//\n\tfloat srnoise(vec2 pos, float rot) {\n\t  // Offset y slightly to hide some rare artifacts\n\t  pos.y += 0.001;\n\t  // Skew to hexagonal grid\n\t  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n  \n\t  vec2 i0 = floor(uv);\n\t  vec2 f0 = fract(uv);\n\t  // Traversal order\n\t  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n\t  // Unskewed grid points in (x,y) space\n\t  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\t  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n\t  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n\t  // Integer grid point indices in (u,v) space\n\t  i1 = i0 + i1;\n\t  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t  // Vectors in unskewed (x,y) coordinates from\n\t  // each of the simplex corners to the evaluation point\n\t  vec2 d0 = pos - p0;\n\t  vec2 d1 = pos - p1;\n\t  vec2 d2 = pos - p2;\n\n\t  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n\t  // wrap points in (x,y), map to (u,v)\n\t  vec3 x = vec3(p0.x, p1.x, p2.x);\n\t  vec3 y = vec3(p0.y, p1.y, p2.y);\n\t  vec3 iuw = x + 0.5 * y;\n\t  vec3 ivw = y;\n  \n\t  // Avoid precision issues in permutation\n\t  iuw = mod289(iuw);\n\t  ivw = mod289(ivw);\n\n\t  // Create gradients from indices\n\t  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n\t  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n\t  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n\t  // Gradients dot vectors to corresponding corners\n\t  // (The derivatives of this are simply the gradients)\n\t  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n  \n\t  // Radial weights from corners\n\t  // 0.8 is the square of 2/sqrt(5), the distance from\n\t  // a grid point to the nearest simplex boundary\n\t  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n\t  // Set influence of each surflet to zero outside radius sqrt(0.8)\n\t  t = max(t, 0.0);\n\n\t  // Fourth power of t\n\t  vec3 t2 = t * t;\n\t  vec3 t4 = t2 * t2;\n  \n\t  // Final noise value is:\n\t  // sum of ((radial weights) times (gradient dot vector from corner))\n\t  float n = dot(t4, w);\n  \n\t  // Rescale to cover the range [-1,1] reasonably well\n\t  return 11.0*n;\n\t}\n\n\t//\n\t// 2-D non-tiling simplex noise with fixed gradients,\n\t// without the analytical derivative.\n\t// This function is implemented as a wrapper to \"srnoise\",\n\t// at the minimal cost of three extra additions.\n\t// Note: if this kind of noise is all you want, there are faster\n\t// GLSL implementations of non-tiling simplex noise out there.\n\t// This one is included mainly for completeness and compatibility\n\t// with the other functions in the file.\n\t//\n\tfloat snoise(vec2 pos) {\n\t  return srnoise(pos, 0.0);\n\t}\n\n\tfloat hash(float x, float y) {\n\t\treturn fract(abs(sin(sin(123.321 + x) * (y + 321.123)) * 456.654));\n\t}\n\t\n\tfloat lerp(float a, float b, float t) {\n\t\treturn a * (1.0 - t) + b * t;\n\t}\n\n\tfloat perlin(float x, float y){\n\t\tfloat col = 0.0;\n\t\tfor (int i = 0; i < 8; i++) \n\t\t{\n\t\t\tfloat fx = floor(x);\n\t\t\tfloat fy = floor(y);\n\t\t\tfloat cx = ceil(x);\n\t\t\tfloat cy = ceil(y);\n\t\t\tfloat a = hash(fx, fy);\n\t\t\tfloat b = hash(fx, cy);\n\t\t\tfloat c = hash(cx, fy);\n\t\t\tfloat d = hash(cx, cy);\n\t\t\tcol += lerp(lerp(a, b, fract(y)), lerp(c, d, fract(y)), fract(x));\n\t\t\tcol /= 2.0;\n\t\t\tx /= 2.0;\n\t\t\ty /= 2.0;\n\t\t}\n\t\treturn col;\n\t}\n\t\n\tfloat dperlin(float x, float y){\n\t\tfloat d = perlin(x, y) * 800.0;\n\t\treturn perlin(x + d, y + d);\n\t}\n\t\n\tfloat ddperlin(float x, float y){\n\t\tfloat d = perlin(x, y) * 800.0;\n\t\treturn dperlin(x + d, y + d);\n\t}\n`\n\nexport { noise };","import { Vector3, Group } from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\r\nimport { Explosion } from './Explosion.js';\r\nclass Obstacles {\r\n  constructor(game) {\r\n    this.game = game\r\n    this.sence = game.sence\r\n    this.loadStart()\r\n    this.loadBomb()\r\n    this.tmpPos = new Vector3()\r\n    this.explosions = [];\r\n  }\r\n\r\n  loadStart() {\r\n    const loader = new GLTFLoader()\r\n    loader.load(require(\"../../../assets/gameSource/plane/star.glb\"), gltf => {\r\n      this.star = gltf.scene.children[0]\r\n      this.star.name = 'star'\r\n      if (this.bomb !== undefined) {\r\n        this.init()\r\n      }\r\n    })\r\n  }\r\n\r\n  loadBomb() {\r\n    const loader = new GLTFLoader()\r\n    loader.load(require(\"../../../assets/gameSource/plane/bomb.glb\"), gltf => {\r\n      this.bomb = gltf.scene.children[0];\r\n      if (this.bomb !== undefined) {\r\n        this.init()\r\n      }\r\n    })\r\n  }\r\n\r\n  init() {\r\n    this.obstacles = []\r\n    const obstacles = new Group()\r\n    obstacles.add(this.star)\r\n    this.bomb.rotation.x = -Math.PI * 0.5\r\n    this.bomb.position.y = 7.5\r\n    obstacles.add(this.bomb)\r\n    let rotate = true\r\n    for (let y = 7.5; y > -8; y -= 2.5) {\r\n      rotate = !rotate\r\n      if (y === 0) {\r\n        continue\r\n      }\r\n      const bomb = this.bomb.clone()\r\n      bomb.rotation.x = rotate ? -Math.PI * 0.5 : 0\r\n      bomb.position.y = y\r\n      obstacles.add(bomb)\r\n    }\r\n    this.obstacles.push(obstacles)\r\n    this.sence.add(obstacles)\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      const obstaclesT = obstacles.clone()\r\n      this.sence.add(obstaclesT)\r\n      this.obstacles.push(obstaclesT)\r\n    }\r\n\r\n    this.reset()\r\n  }\r\n\r\n  reset() {\r\n    this.obstacleSpawn = { pos: 20, offset: 5 };\r\n    this.obstacles.forEach(obstacle => this.respawnObstacle(obstacle));\r\n    let count;\r\n        while( this.explosions.length>0 && count<100){\r\n            this.explosions[0].onComplete();\r\n            count++;\r\n        }\r\n  }\r\n\r\n  removeExplosion( explosion ){\r\n    const index = this.explosions.indexOf( explosion );\r\n    if (index != -1) this.explosions.indexOf(index, 1);\r\n}\r\n\r\n  respawnObstacle(obstacle) {\r\n    this.obstacleSpawn.pos += 30;\r\n    const offset = (Math.random() * 2 - 1) * this.obstacleSpawn.offset;\r\n    this.obstacleSpawn.offset += 0.2;\r\n    obstacle.position.set(0, offset, this.obstacleSpawn.pos);\r\n    obstacle.children[0].rotation.y = Math.random() * Math.PI * 2;\r\n    obstacle.userData.hit = false;\r\n    obstacle.children.forEach(child => {\r\n      child.visible = true;\r\n    });\r\n  }\r\n\r\n  update(pos) {\r\n    let collisionObstacle;\r\n\r\n    this.obstacles.forEach(obstacle => {\r\n      obstacle.children[0].rotateY(0.01);\r\n      const relativePosZ = obstacle.position.z - pos.z;\r\n      if (Math.abs(relativePosZ) < 2 && !obstacle.userData.hit) {\r\n        collisionObstacle = obstacle;\r\n      }\r\n      if (relativePosZ < -20) {\r\n        this.respawnObstacle(obstacle);\r\n      }\r\n    });\r\n\r\n\r\n    if (collisionObstacle !== undefined) {\r\n      collisionObstacle.children.some(child => {\r\n        child.getWorldPosition(this.tmpPos);\r\n        const dist = this.tmpPos.distanceToSquared(pos);\r\n        if (dist < 5) {\r\n          collisionObstacle.userData.hit = true;\r\n          this.hit(child);\r\n          return true;\r\n        }\r\n      })\r\n\r\n    }\r\n  }\r\n\r\n  hit(obj) {\r\n    if (obj.name == 'star') {\r\n      obj.visible = false;\r\n      this.game.incScore();\r\n    } else {\r\n      this.explosions.push( new Explosion(obj, this) );\r\n      this.game.decLives();\r\n    }\r\n  }\r\n\r\n  unMount() {\r\n    for (const item of this.obstacles) {\r\n      this.sence.remove(item)\r\n    }\r\n  }\r\n}\r\n\r\nexport { Obstacles }","import React, { useEffect, useRef } from \"react\";\r\nimport * as Three from 'three'\r\nimport { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader\"\r\nimport { Player } from \"./Player\";\r\nimport styles from './plane.module.css'\r\nimport { Obstacles } from \"./Obstacles\";\r\n\r\nconst sence = new Three.Scene();\r\nconst camera = new Three.PerspectiveCamera(\r\n    70,\r\n    window.innerWidth/window.innerHeight,\r\n    0.01,\r\n    100\r\n)\r\n\r\ncamera.position.set(-4.37,0,-4.75)\r\ncamera.lookAt(0, 0 , 6)\r\nconst cameraController = new Three.Object3D()\r\ncameraController.add(camera)\r\nconst cameraTarget = new Three.Vector3(0, 0, 6)\r\n\r\nsence.add(cameraController)\r\n\r\nconst ambient = new Three.HemisphereLight(0xffffff, 0xbbbbff, 1)\r\nambient.position.set(0.5, 1, 0.25)\r\nsence.add(ambient)\r\n\r\nconst renderer = new Three.WebGLRenderer()\r\nrenderer.setPixelRatio(window.devicePixelRatio)\r\nrenderer.outputEncoding = Three.sRGBEncoding;\r\nrenderer.setSize(window.innerWidth, window.innerHeight)\r\n\r\nexport default function() {\r\n    const clock = new Three.Clock()\r\n    let player, obstacles\r\n    const info = {\r\n      spaceKey:false,\r\n      active: false,\r\n      sence,\r\n      sounds: {}\r\n    }\r\n    const container = useRef()\r\n  \r\n    useEffect(() => {\r\n      window.addEventListener( 'resize', onWindowResize, false );//窗口变化监听\r\n      container.current.appendChild(renderer.domElement)\r\n      init()\r\n      refresh()\r\n      return () => {\r\n        document.removeEventListener('keydown', keyDown)\r\n        document.removeEventListener('keyup', keyUp)\r\n        stopAllAudio()\r\n        sence.remove(player.plane)\r\n        obstacles.unMount()\r\n      }\r\n    }, [])\r\n\r\n    function init() {\r\n      info.incScore = incScore\r\n      info.decLives = decLives\r\n      setEnvironment()\r\n      initSkyBox()\r\n      initPlayer()\r\n      initObstacles()\r\n      initEvent()\r\n      loadAudio()\r\n    }\r\n\r\n    function loadAudio() {\r\n      const list = [\r\n        {tag: 'explosion', path: require(\"../../../assets/gameSource/plane/explosion.mp3\")},\r\n        {tag: 'engine', path: require(\"../../../assets/gameSource/plane/engine.mp3\"), loop: true},\r\n        {tag: 'gliss', path: require(\"../../../assets/gameSource/plane/gliss.mp3\")},\r\n        {tag: 'gameover', path: require(\"../../../assets/gameSource/plane/gameover.mp3\")},\r\n        {tag: 'bonus', path: require(\"../../../assets/gameSource/plane/bonus.mp3\")}\r\n      ]\r\n      const listener = new Three.AudioListener()\r\n      camera.add(listener)\r\n      list.forEach( e => {\r\n        const sound = new Three.Audio(listener)\r\n        info.sounds[e.tag] = sound\r\n        const audioLoader = new Three.AudioLoader().load(e.path, data => {\r\n          sound.setBuffer(data)\r\n          sound.setLoop(!!e.loop)\r\n          sound.setVolume(0.5)\r\n        })\r\n      })\r\n    }\r\n\r\n    function stopAllAudio() {\r\n      const data = info.sounds\r\n      for (const k in data) {\r\n        if (data[k] && data[k].isPlaying) {\r\n          data[k].stop()\r\n        }\r\n      }\r\n    }\r\n\r\n    function playAudio(name) {\r\n      const soundData = info.sounds[name]\r\n      if (soundData !== undefined ) {\r\n        if (soundData.isPlaying) {\r\n          soundData.stop()\r\n        }\r\n        soundData.play()\r\n      }\r\n    }\r\n\r\n    function incScore() {\r\n      info.score++\r\n      const elm = document.getElementById('score')\r\n\r\n      if (info.score%3===0) {\r\n        info.bonusScore += 3\r\n        playAudio('bonus')\r\n      } else {\r\n        playAudio('gliss')\r\n      }\r\n\r\n      elm.innerHTML = info.score + info.bonusScore\r\n    }\r\n\r\n    function decLives() {\r\n      info.lives--\r\n      const elm = document.getElementById(\"lives\")\r\n      elm.innerHTML = info.lives\r\n      if (info.lives <= 0) {\r\n        setTimeout(gameOver, 1200);\r\n      }\r\n      playAudio('explosion')\r\n    }\r\n\r\n    function gameOver() {\r\n      info.active = false\r\n      const gameover = document.getElementById('gameover')\r\n      const btn = document.getElementById('playBtn')\r\n\r\n      gameover.style.display = 'block'\r\n      btn.style.display = 'block'\r\n\r\n      player.visible = false\r\n\r\n      stopAllAudio()\r\n      playAudio('gameover')\r\n    }\r\n\r\n    function initObstacles() {\r\n      obstacles = new Obstacles(info)\r\n    }\r\n\r\n    function initEvent() {\r\n      document.addEventListener('keydown', keyDown)\r\n      document.addEventListener('keyup', keyUp)\r\n      container.current.addEventListener('mousedown', mouseDown)\r\n      container.current.addEventListener('mouseup', mouseup)\r\n    }\r\n\r\n    function mouseDown() {\r\n      info.spaceKey = true\r\n    }\r\n\r\n    function mouseup() {\r\n      info.spaceKey = false\r\n    }\r\n\r\n    function keyDown(e) {\r\n      switch (e.keyCode) {\r\n        case 32:\r\n          info.spaceKey = true\r\n      }\r\n    }\r\n    function keyUp(e) {\r\n      switch (e.keyCode) {\r\n        case 32:\r\n          info.spaceKey = false\r\n      }\r\n    }\r\n    \r\n    function initSkyBox() {\r\n      sence.background = new Three.CubeTextureLoader()\r\n        .load([\r\n          require(\"../../../assets/gameSource/plane/paintedsky/px.jpg\"),\r\n          require(\"../../../assets/gameSource/plane/paintedsky/nx.jpg\"),\r\n          require(\"../../../assets/gameSource/plane/paintedsky/py.jpg\"),\r\n          require(\"../../../assets/gameSource/plane/paintedsky/ny.jpg\"),\r\n          require(\"../../../assets/gameSource/plane/paintedsky/pz.jpg\"),\r\n          require(\"../../../assets/gameSource/plane/paintedsky/nz.jpg\")\r\n        ])\r\n    }\r\n\r\n    function initPlayer() {\r\n      player = new Player(info)\r\n    }\r\n\r\n    function setEnvironment() {\r\n      const loader = new RGBELoader()\r\n      const pmremGenerator = new Three.PMREMGenerator(renderer)\r\n      pmremGenerator.compileEquirectangularShader()\r\n      loader.load(require(\"../../../assets/gameSource/hdr/venice_sunset_1k.hdr\"), t => {\r\n        const envMap = pmremGenerator.fromEquirectangular(t).texture\r\n        pmremGenerator.dispose()\r\n        sence.environment = envMap\r\n      }, undefined, e => {\r\n        console.log('EEEE', e)\r\n      })\r\n    }\r\n\r\n    function onWindowResize() {\r\n      const width = window.innerWidth;\r\n      const height = window.innerHeight;\r\n\r\n      camera.aspect = width / height;//获得当前摄像机缩放比\r\n      camera.updateProjectionMatrix();//更新矩阵\r\n      renderer.setSize( width, height );\r\n    }\r\n\r\n    function updateCamera() {\r\n      cameraController.position.copy( player.position );\r\n      cameraController.position.y = 0;\r\n      cameraTarget.copy(player.position);\r\n      cameraTarget.z += 6;\r\n      camera.lookAt( cameraTarget );\r\n    }\r\n\r\n    function refresh() {\r\n      const dt = clock.getDelta();\r\n      const time = clock.getElapsedTime()\r\n      player.update(time)\r\n      if (info.active) {\r\n        obstacles.update(player.position, dt)\r\n      }\r\n      updateCamera()\r\n      renderer.render(sence, camera)\r\n      window.requestAnimationFrame(refresh)\r\n    }\r\n  \r\n    function start() {\r\n        const instructions = document.getElementById('instructions');\r\n        const btn = document.getElementById('playBtn');\r\n        const gameover = document.getElementById(\"gameover\")\r\n\r\n        gameover.style.display = 'none'\r\n        instructions.style.display = 'none';\r\n        btn.style.display = 'none';\r\n\r\n        info.score = 0\r\n        info.bonusScore = 0\r\n        info.lives = 3\r\n\r\n        const elm = document.getElementById('score')\r\n        elm.innerHTML = info.score\r\n        const elm2 = document.getElementById('lives')\r\n        elm2.innerHTML = info.lives\r\n\r\n\r\n        player.reset()\r\n        obstacles.reset()\r\n\r\n        info.active = true;\r\n\r\n        playAudio('engine')\r\n    }\r\n\r\n    return <div>\r\n      <p className={styles.instructions} id=\"instructions\">操作：长按空格或者鼠标</p>\r\n      <div id=\"info\" className={styles.info}>\r\n        <div id=\"life\" className={styles.life}>\r\n          <img className={styles.info_img} src={require(\"../../../assets/gameSource/plane/plane-icon.png\")}/>\r\n          <div id=\"lives\" className={styles.lives}>3</div>\r\n        </div>\r\n        <div id=\"score_panel\" className={styles.score_panel}>\r\n          <div className={styles.score} id=\"score\">0</div>\r\n          <img className={styles.info_img} src={require(\"../../../assets/gameSource/plane/star-icon.png\")}/>\r\n        </div>\r\n      </div>\r\n      <p id=\"gameover\" className={styles.gameover}>Game Over</p>\r\n      <button className={styles.playBtn} id=\"playBtn\" onClick={start}>开始</button>\r\n      <div ref={container}></div>\r\n    </div>\r\n  }","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearEncoding,\n\tLinearFilter\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* return codes for rgbe routines */\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\n\t\t\tRGBE_RETURN_FAILURE = - 1,\n\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn RGBE_RETURN_FAILURE;\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\n\n\t\t\tconst w = rgbe_header_info.width,\n\t\t\t\th = rgbe_header_info.height,\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\n\n\t\t\t\tlet data, type;\n\t\t\t\tlet numElements;\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = floatArray;\n\t\t\t\t\t\ttype = FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = halfArray;\n\t\t\t\t\t\ttype = HalfFloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: w, height: h,\n\t\t\t\t\tdata: data,\n\t\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\t\ttype: type\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n"],"names":["Player","info","_classCallCheck","this","game","scene","sence","load","tmpPos","Vector3","_createClass","key","get","undefined","plane","getWorldPosition","set","mode","visible","value","_this","GLTFLoader","require","gltf","add","propeller","getObjectByName","velocity","position","time","rotateZ","active","spaceKey","y","z","rotation","Math","sin","translateZ","translateY","cos","Explosion","parent","obstacles","geometry","IcosahedronGeometry","uniforms","u_time","u_mouse","x","u_opacity","u_resolution","u_tex","TextureLoader","ShaderChunk","material","ShaderMaterial","vertexShader","vshader","fragmentShader","fshader","transparent","opacity","ball","Mesh","scale","tweens","gsap","duration","onComplete","complete","remove","dispose","removeExplosion","Obstacles","loadStart","loadBomb","explosions","star","children","name","bomb","init","_this2","Group","PI","rotate","clone","push","i","obstaclesT","reset","count","_this3","obstacleSpawn","pos","offset","forEach","obstacle","respawnObstacle","length","explosion","index","indexOf","random","userData","hit","child","collisionObstacle","_this4","rotateY","relativePosZ","abs","some","distanceToSquared","obj","incScore","decLives","_step","_iterator","_createForOfIteratorHelper","s","n","done","item","err","e","f","Three","camera","window","innerWidth","innerHeight","lookAt","cameraController","cameraTarget","ambient","renderer","player","clock","sounds","container","useRef","stopAllAudio","data","k","isPlaying","stop","playAudio","soundData","play","score","elm","document","getElementById","bonusScore","innerHTML","lives","setTimeout","gameOver","gameover","btn","style","display","mouseDown","mouseup","keyDown","keyCode","keyUp","onWindowResize","width","height","aspect","updateProjectionMatrix","setSize","refresh","dt","getDelta","getElapsedTime","update","copy","render","requestAnimationFrame","useEffect","addEventListener","current","appendChild","domElement","loader","RGBELoader","pmremGenerator","compileEquirectangularShader","t","envMap","fromEquirectangular","texture","environment","console","log","setEnvironment","background","list","tag","path","loop","listener","sound","setBuffer","setLoop","setVolume","loadAudio","removeEventListener","unMount","_jsxs","_jsx","className","styles","id","src","onClick","instructions","ref","setPixelRatio","devicePixelRatio","outputEncoding","_DataTextureLoader","_inherits","_super","_createSuper","manager","call","type","HalfFloatType","buffer","rgbe_error","rgbe_error_code","msg","error","fgets","lineLimit","consume","p","len","chunk","String","fromCharCode","apply","Uint16Array","subarray","byteLength","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","pow","RGBEByteToRGBHalf","DataUtils","min","byteArray","Uint8Array","rgbe_header_info","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","scanline_width","data_rgba","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","isEncodedRun","byteValue","l","off","RGBE_ReadPixels_RLE","numElements","FloatType","floatArray","Float32Array","j","halfArray","url","onLoad","onProgress","onError","_get","_getPrototypeOf","prototype","texData","encoding","LinearEncoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","DataTextureLoader"],"sourceRoot":""}