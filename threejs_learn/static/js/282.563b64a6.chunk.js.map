{"version":3,"file":"static/js/282.563b64a6.chunk.js","mappings":"wKAAA,2ICAA,kiF,SCMe,SAAS,IACtB,IAAMA,EAAQ,IAAIC,EAAAA,IACZC,EAAS,IAAID,EAAAA,IACjB,GACAE,OAAOC,WAAaD,OAAOE,YAC3B,GACA,KAGFH,EAAOI,SAASC,IAAI,EAAG,EAAG,GAC1BP,EAAMQ,IAAIN,GAEV,IAAIO,EAAW,IAAIR,EAAAA,IAAoB,EAAG,GACpCS,EAAW,CACfC,OAAQ,CAAEC,KAAM,IAAKC,MAAO,GAC5BC,aAAc,CAAEF,KAAM,KAAMC,MAAO,IAAIZ,EAAAA,MAGrCc,EAAW,IAAId,EAAAA,IAAqB,CACtCS,SAAUA,EACVM,aAAcA,EACdC,eAAgBA,IAIdC,EAAO,IAAIjB,EAAAA,IAAWQ,EAAUM,GACpCf,EAAMQ,IAAIU,GAEV,IAKIC,EALEC,EAAW,IAAInB,EAAAA,IAIrBmB,EAASC,QAAQlB,OAAOC,WAAYD,OAAOE,aAE3C,IAAMiB,GAAYC,EAAAA,EAAAA,UAYlB,SAASC,IACP,IAAMC,EAAQtB,OAAOC,WACfsB,EAASvB,OAAOE,YAEtBH,EAAOyB,OAASF,EAAQC,EACxBxB,EAAO0B,yBACPR,EAASC,QAASI,EAAOC,EAC3B,CAEA,SAASG,EAAQC,GACVX,IACLT,EAASC,OAAOE,OAASM,EAAMY,WAC/BX,EAASY,OAAOhC,EAAOE,GACvBC,OAAO8B,sBAAsBJ,GAC/B,CAEA,OA1BAK,EAAAA,EAAAA,YAAU,WAKR,OAJAf,EAAQ,IAAIlB,EAAAA,IACZE,OAAOgC,iBAAkB,SAAUX,GAAgB,GACnDF,EAAUc,QAAQC,YAAYjB,EAASkB,YACvCT,IACO,WACLV,EAAQ,IACV,CACF,GAAG,KAkBIoB,EAAAA,EAAAA,KAAA,OAAKC,IAAKlB,GACnB,C","sources":["practice/shader/falling/glsl/vShader.js","practice/shader/falling/glsl/fShader.js","practice/shader/falling/falling.js"],"sourcesContent":["export default /*glsl*/`  \r\nvarying vec2 vUv;\r\nvoid main() { \r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}`;","export default /* glsl */`\r\n#define S smoothstep\r\n#define HEART_COLOR_F vec3(1.0,.05,0.05)\r\n#define HEART_COLOR_B vec3(1.0,0.25,0.25)\r\n#define BG_COLOR vec3(0.5,0.05,0.05)\r\n#define NB_HEARTS 50.0\r\n\r\nvarying vec2 vUv;\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\n\r\nmat2 Rot(float angle){\r\n  float c = cos(angle);\r\n  float s = sin(angle);\r\n  return mat2(c,-s,s,c);\r\n}\r\n\r\nfloat smax(float a, float b, float k){\r\n  float h = clamp((b-a)/k+0.5, 0., 1.);\r\n  return mix(a, b, h) + h*(1.0-h)*k*0.5;\r\n}\r\n\r\nvec4 Heart(vec2 uv, float radius, float blur){\r\n  float angle = sin(u_time*0.1)*0.25;    \r\n  blur *= radius;\r\n  uv -= vec2(0.0,-radius);\r\n  uv *= Rot(angle*length(uv)*2.);\r\n  uv -= vec2(0.0,+radius);\r\n  uv.x *= 0.7;\r\n  uv.y -= smax(sqrt(abs(uv.x))*.5, blur, 0.1) -.1 - blur*0.5;\r\n  float d = length(uv);\r\n  float c = S(radius+blur,radius-blur-0.01,d);\r\n  return vec4(vec3(1),c);\r\n}\r\n\r\nvec3 Transform(vec3 p, float a){\r\n  p.xz *= Rot(a);\r\n  p.xy *= Rot(a*0.765);\r\n  return p;\r\n}\r\n\r\nvec4 HeartBall(vec3 ro, vec3 rd, vec3 pos, float radius, float angle, float blur){\r\n\r\n  vec4 col = vec4(0);\r\n  float t  = dot(pos-ro, rd);\r\n  vec3  p  = ro + rd*t;\r\n  float y  = length(pos-p);    \r\n  if (y<1.0){\r\n      float x = sqrt(1.0-y);\r\n      vec3 pF = ro + rd*(t-x) - pos;         // front intersection\r\n      vec3 pB = ro + rd*(t+x) - pos;         // back intersection\r\n      pF = Transform(pF,angle);\r\n      pB = Transform(pB,angle);    \r\n      vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);\r\n      vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);\r\n      vec4 front = Heart(uvF, radius, blur);\r\n      vec4 back = Heart(uvB, radius, blur);\r\n      front.xyz *= HEART_COLOR_F;\r\n      back.xyz  *= HEART_COLOR_B;\r\n      col = mix(back, front, front.a) ;\r\n  }\r\n  return col;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n    vec2 uv = vUv.xy*2.0-1.0;\r\n    vec3 bg = BG_COLOR*(uv.y+1.0);\r\n    vec4 col = vec4(bg,1.0);\r\n    vec3 ro = vec3(0,0,-4);\r\n    vec3 rd = normalize(vec3(uv,1));\r\n    \r\n    for(float i=0.0; i<1.0 ; i+=1.0/NB_HEARTS){\r\n        float x = mix(-4.0, 4.0, fract(sin(i*735.25)*457.56));\r\n        float y = mix(-5.0,5.0,fract(i-u_time*0.1));\r\n        float z = mix(3.0, 0.0, i);\r\n        float radius = S(3.0,0.0,z)*0.3+0.3 ;\r\n        // 飘落旋转角度\r\n        float angle = u_time+i*985.989;\r\n        // blur in the background / Blur in the foreground \r\n        float blur = S(0.25,0.75,abs(z-1.5))/4.0;\r\n        vec3 pos = vec3(x,y,z);\r\n        vec4 heart = HeartBall(ro, rd, pos, radius, angle, blur); \r\n        // heart.xyz = vec3(abs(1.5-z)/1.5 );\r\n        col = mix(col, heart, heart.a);\r\n    }\r\n    gl_FragColor = col;\r\n}`","import React, { useEffect, useRef } from \"react\";\r\nimport * as Three from 'three'\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\r\nimport vertexShader from './glsl/vShader'\r\nimport fragmentShader from './glsl/fShader'\r\n\r\nexport default function () {\r\n  const sence = new Three.Scene();\r\n  const camera = new Three.PerspectiveCamera(\r\n    75,\r\n    window.innerWidth / window.innerHeight,\r\n    0.1,\r\n    1000\r\n  )\r\n\r\n  camera.position.set(0, 0, 1)\r\n  sence.add(camera)\r\n\r\n  var geometry = new Three.PlaneGeometry(3, 3);\r\n  const uniforms = {\r\n    u_time: { type: \"f\", value: 1.0 },\r\n    u_resolution: { type: \"v2\", value: new Three.Vector2() }\r\n  };\r\n\r\n  var material = new Three.ShaderMaterial({\r\n    uniforms: uniforms,\r\n    vertexShader: vertexShader,\r\n    fragmentShader: fragmentShader,\r\n    // side: Three.DoubleSide\r\n  });\r\n\r\n  var mesh = new Three.Mesh(geometry, material);\r\n  sence.add(mesh);\r\n\r\n  const renderer = new Three.WebGLRenderer()\r\n  // const controls = new OrbitControls(camera, renderer.domElement)\r\n  // // 设置阻尼，让控制器更真实, 必须在动画循环调用update方法\r\n  // controls.enableDamping = true\r\n  renderer.setSize(window.innerWidth, window.innerHeight)\r\n  let clock;\r\n  const container = useRef()\r\n\r\n  useEffect(() => {\r\n    clock = new Three.Clock();\r\n    window.addEventListener( 'resize', onWindowResize, false );//窗口变化监听\r\n    container.current.appendChild(renderer.domElement)\r\n    refresh()\r\n    return () => {\r\n      clock = null;\r\n    }\r\n  }, [])\r\n\r\n  function onWindowResize() {\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n\r\n    camera.aspect = width / height;//获得当前摄像机缩放比\r\n    camera.updateProjectionMatrix();//更新矩阵\r\n    renderer.setSize( width, height );\r\n  }\r\n\r\n  function refresh(time) {\r\n    if (!clock) return;\r\n    uniforms.u_time.value += clock.getDelta();\r\n    renderer.render(sence, camera)\r\n    window.requestAnimationFrame(refresh)\r\n  }\r\n\r\n  return <div ref={container}></div>\r\n}"],"names":["sence","Three","camera","window","innerWidth","innerHeight","position","set","add","geometry","uniforms","u_time","type","value","u_resolution","material","vertexShader","fragmentShader","mesh","clock","renderer","setSize","container","useRef","onWindowResize","width","height","aspect","updateProjectionMatrix","refresh","time","getDelta","render","requestAnimationFrame","useEffect","addEventListener","current","appendChild","domElement","_jsx","ref"],"sourceRoot":""}